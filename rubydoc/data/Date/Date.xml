<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<help>
  <comment>&lt;p&gt;Class representing a date.&lt;/p&gt;&lt;p&gt;See the documentation to the file date.rb for an overview.&lt;/p&gt;&lt;p&gt;Internally, the date is represented as an Astronomical Julian Day Number, &lt;tt&gt;ajd&lt;/tt&gt;. The Day of Calendar Reform, &lt;tt&gt;sg&lt;/tt&gt;, is also stored, for conversions to other date formats. (There is also an &lt;tt&gt;of&lt;/tt&gt; field for a time zone offset, but this is only for the use of the DateTime subclass.)&lt;/p&gt;&lt;p&gt;A new Date object is created using one of the object creation class methods named after the corresponding date format, and the arguments appropriate to that date format; for instance, Date::civil() (aliased to Date::new()) with year, month, and day-of-month, or Date::ordinal() with year and day-of-year. All of these object creation class methods also take the Day of Calendar Reform as an optional argument.&lt;/p&gt;&lt;p&gt;Date objects are immutable once created.&lt;/p&gt;&lt;p&gt;Once a Date has been created, date values can be retrieved for the different date formats supported using instance methods. For instance, #mon() gives the Civil month, #cwday() gives the Commercial day of the week, and #yday() gives the Ordinal day of the year. Date values can be retrieved in any format, regardless of what format was used to create the Date instance.&lt;/p&gt;&lt;p&gt;The Date class includes the Comparable module, allowing date objects to be compared and sorted, ranges of dates to be created, and so forth.&lt;/p&gt;</comment>
  <methods>
    <method name='_load'>&lt;p&gt;Load from Marshall format.&lt;/p&gt;</method>
    <method name='_parse'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='_strptime'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='ajd_to_amjd'>&lt;p&gt;Convert an Astronomical Julian Day Number to an Astronomical Modified Julian Day Number.&lt;/p&gt;</method>
    <method name='ajd_to_jd'>&lt;p&gt;Convert an Astronomical Julian Day Number to a (civil) Julian Day Number.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;ajd&lt;/tt&gt; is the Astronomical Julian Day Number to convert. &lt;tt&gt;of&lt;/tt&gt; is the offset from UTC as a fraction of a day (defaults to 0).&lt;/p&gt;&lt;p&gt;Returns the (civil) Julian Day Number as [day_number, fraction] where &lt;tt&gt;fraction&lt;/tt&gt; is always 1/2.&lt;/p&gt;</method>
    <method name='amjd_to_ajd'>&lt;p&gt;Convert an Astronomical Modified Julian Day Number to an Astronomical Julian Day Number.&lt;/p&gt;</method>
    <method name='civil'>&lt;p&gt;Create a new Date object for the Civil Date specified by year &lt;tt&gt;y&lt;/tt&gt;, month &lt;tt&gt;m&lt;/tt&gt;, and day-of-month &lt;tt&gt;d&lt;/tt&gt;.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;m&lt;/tt&gt; and &lt;tt&gt;d&lt;/tt&gt; can be negative, in which case they count backwards from the end of the year and the end of the month respectively. No wraparound is performed, however, and invalid values cause an ArgumentError to be raised. can be negative&lt;/p&gt;&lt;p&gt;&lt;tt&gt;y&lt;/tt&gt; defaults to -4712, &lt;tt&gt;m&lt;/tt&gt; to 1, and &lt;tt&gt;d&lt;/tt&gt; to 1; this is Julian Day Number day 0.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='civil_to_jd'>&lt;p&gt;Convert a Civil Date to a Julian Day Number. &lt;tt&gt;y&lt;/tt&gt;, &lt;tt&gt;m&lt;/tt&gt;, and &lt;tt&gt;d&lt;/tt&gt; are the year, month, and day of the month. &lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;&lt;p&gt;Returns the corresponding Julian Day Number.&lt;/p&gt;</method>
    <method name='commercial'>&lt;p&gt;Create a new Date object for the Commercial Date specified by year &lt;tt&gt;y&lt;/tt&gt;, week-of-year &lt;tt&gt;w&lt;/tt&gt;, and day-of-week &lt;tt&gt;d&lt;/tt&gt;.&lt;/p&gt;&lt;p&gt;Monday is day-of-week 1; Sunday is day-of-week 7.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;w&lt;/tt&gt; and &lt;tt&gt;d&lt;/tt&gt; can be negative, in which case they count backwards from the end of the year and the end of the week respectively. No wraparound is performed, however, and invalid values cause an ArgumentError to be raised.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;y&lt;/tt&gt; defaults to 1582, &lt;tt&gt;w&lt;/tt&gt; to 41, and &lt;tt&gt;d&lt;/tt&gt; to 5, the Day of Calendar Reform for Italy and the Catholic countries.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='commercial_to_jd'>&lt;p&gt;Convert a Commercial Date to a Julian Day Number.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;y&lt;/tt&gt;, &lt;tt&gt;w&lt;/tt&gt;, and &lt;tt&gt;d&lt;/tt&gt; are the (commercial) year, week of the year, and day of the week of the Commercial Date to convert. &lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='day_fraction_to_time'>&lt;p&gt;Convert a fractional day &lt;tt&gt;fr&lt;/tt&gt; to [hours, minutes, seconds, fraction_of_a_second]&lt;/p&gt;</method>
    <method name='gregorian_leap?'>&lt;p&gt;Is a year a leap year in the Gregorian calendar?&lt;/p&gt;&lt;p&gt;All years divisible by 4 are leap years in the Gregorian calendar, except for years divisible by 100 and not by 400.&lt;/p&gt;</method>
    <method name='jd'>&lt;p&gt;Create a new Date object from a Julian Day Number.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;jd&lt;/tt&gt; is the Julian Day Number; if not specified, it defaults to 0. &lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='jd_to_ajd'>&lt;p&gt;Convert a (civil) Julian Day Number to an Astronomical Julian Day Number.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;jd&lt;/tt&gt; is the Julian Day Number to convert, and &lt;tt&gt;fr&lt;/tt&gt; is a fractional day. &lt;tt&gt;of&lt;/tt&gt; is the offset from UTC as a fraction of a day (defaults to 0).&lt;/p&gt;&lt;p&gt;Returns the Astronomical Julian Day Number as a single numeric value.&lt;/p&gt;</method>
    <method name='jd_to_civil'>&lt;p&gt;Convert a Julian Day Number to a Civil Date. &lt;tt&gt;jd&lt;/tt&gt; is the Julian Day Number. &lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;&lt;p&gt;Returns the corresponding [year, month, day_of_month] as a three-element array.&lt;/p&gt;</method>
    <method name='jd_to_commercial'>&lt;p&gt;Convert a Julian Day Number to a Commercial Date&lt;/p&gt;&lt;p&gt;&lt;tt&gt;jd&lt;/tt&gt; is the Julian Day Number to convert. &lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;&lt;p&gt;Returns the corresponding Commercial Date as [commercial_year, week_of_year, day_of_week]&lt;/p&gt;</method>
    <method name='jd_to_ld'>&lt;p&gt;Convert a Julian Day Number to the number of days since the adoption of the Gregorian Calendar (in Italy).&lt;/p&gt;</method>
    <method name='jd_to_mjd'>&lt;p&gt;Convert a Julian Day Number to a Modified Julian Day Number.&lt;/p&gt;</method>
    <method name='jd_to_ordinal'>&lt;p&gt;Convert a Julian Day Number to an Ordinal Date.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;jd&lt;/tt&gt; is the Julian Day Number to convert. &lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;&lt;p&gt;Returns the corresponding Ordinal Date as [year, day_of_year]&lt;/p&gt;</method>
    <method name='jd_to_wday'>&lt;p&gt;Convert a Julian Day Number to the day of the week.&lt;/p&gt;&lt;p&gt;Sunday is day-of-week 0; Saturday is day-of-week 6.&lt;/p&gt;</method>
    <method name='julian_leap?'>&lt;p&gt;Is a year a leap year in the Julian calendar?&lt;/p&gt;&lt;p&gt;All years divisible by 4 are leap years in the Julian calendar.&lt;/p&gt;</method>
    <method name='ld_to_jd'>&lt;p&gt;Convert a count of the number of days since the adoption of the Gregorian Calendar (in Italy) to a Julian Day Number.&lt;/p&gt;</method>
    <method name='mjd_to_jd'>&lt;p&gt;Convert a Modified Julian Day Number to a Julian Day Number.&lt;/p&gt;</method>
    <method name='new'>&lt;p&gt;&lt;b&gt;NOTE&lt;/b&gt; this is the documentation for the method new0(). If you are reading this as the documentation for new(), that is because rdoc doesn&apos;t fully support the aliasing of the initialize() method. new() is in fact an alias for #civil(): read the documentation for that method instead.&lt;/p&gt;&lt;p&gt;Create a new Date object.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;ajd&lt;/tt&gt; is the Astronomical Julian Day Number. &lt;tt&gt;of&lt;/tt&gt; is the offset from UTC as a fraction of a day. Both default to 0.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform to use for this Date object.&lt;/p&gt;&lt;p&gt;Using one of the factory methods such as Date::civil is generally easier and safer.&lt;/p&gt;</method>
    <method name='ns?'>&lt;p&gt;Does a given Julian Day Number fall inside the new-style (Gregorian) calendar?&lt;/p&gt;&lt;p&gt;The reverse of self.os? See the documentation for that method for more details.&lt;/p&gt;</method>
    <method name='ordinal'>&lt;p&gt;Create a new Date object from an Ordinal Date, specified by year &lt;tt&gt;y&lt;/tt&gt; and day-of-year &lt;tt&gt;d&lt;/tt&gt;. &lt;tt&gt;d&lt;/tt&gt; can be negative, in which it counts backwards from the end of the year. No year wraparound is performed, however. An invalid value for &lt;tt&gt;d&lt;/tt&gt; results in an ArgumentError being raised.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;y&lt;/tt&gt; defaults to -4712, and &lt;tt&gt;d&lt;/tt&gt; to 1; this is Julian Day Number day 0.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='ordinal_to_jd'>&lt;p&gt;Convert an Ordinal Date to a Julian Day Number.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;y&lt;/tt&gt; and &lt;tt&gt;d&lt;/tt&gt; are the year and day-of-year to convert. &lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;&lt;p&gt;Returns the corresponding Julian Day Number.&lt;/p&gt;</method>
    <method name='os?'>&lt;p&gt;Does a given Julian Day Number fall inside the old-style (Julian) calendar?&lt;/p&gt;&lt;p&gt;&lt;tt&gt;jd&lt;/tt&gt; is the Julian Day Number in question. &lt;tt&gt;sg&lt;/tt&gt; may be Date::GREGORIAN, in which case the answer is false; it may be Date::JULIAN, in which case the answer is true; or it may a number representing the Day of Calendar Reform. Date::ENGLAND and Date::ITALY are two possible such days.&lt;/p&gt;</method>
    <method name='parse'>&lt;p&gt;Create a new Date object by parsing from a String, without specifying the format.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;str&lt;/tt&gt; is a String holding a date representation. &lt;tt&gt;comp&lt;/tt&gt; specifies whether to interpret 2-digit years as 19XX (&gt;= 69) or 20XX (&lt; 69); the default is not to. The method will attempt to parse a date from the String using various heuristics; see #_parse in date/format.rb for more details. If parsing fails, an ArgumentError will be raised.&lt;/p&gt;&lt;p&gt;The default &lt;tt&gt;str&lt;/tt&gt; is &apos;-4712-01-01&apos;; this is Julian Day Number day 0.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='strptime'>&lt;p&gt;Create a new Date object by parsing from a String according to a specified format.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;str&lt;/tt&gt; is a String holding a date representation. &lt;tt&gt;fmt&lt;/tt&gt; is the format that the date is in. See date/format.rb for details on supported formats.&lt;/p&gt;&lt;p&gt;The default &lt;tt&gt;str&lt;/tt&gt; is &apos;-4712-01-01&apos;, and the default &lt;tt&gt;fmt&lt;/tt&gt; is &apos;%F&apos;, which means Year-Month-Day_of_Month. This gives Julian Day Number day 0.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;&lt;p&gt;An ArgumentError will be raised if &lt;tt&gt;str&lt;/tt&gt; cannot be parsed.&lt;/p&gt;</method>
    <method name='time_to_day_fraction'>&lt;p&gt;Convert an &lt;tt&gt;h&lt;/tt&gt; hour, &lt;tt&gt;min&lt;/tt&gt; minutes, &lt;tt&gt;s&lt;/tt&gt; seconds period to a fractional day.&lt;/p&gt;</method>
    <method name='today'>&lt;p&gt;Create a new Date object representing today.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='valid_civil?'>&lt;p&gt;Do year &lt;tt&gt;y&lt;/tt&gt;, month &lt;tt&gt;m&lt;/tt&gt;, and day-of-month &lt;tt&gt;d&lt;/tt&gt; make a valid Civil Date? Returns the corresponding Julian Day Number if they do, nil if they don&apos;t.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;m&lt;/tt&gt; and &lt;tt&gt;d&lt;/tt&gt; can be negative, in which case they count backwards from the end of the year and the end of the month respectively. No wraparound is performed, however, and invalid values cause an ArgumentError to be raised. A date falling in the period skipped in the Day of Calendar Reform adjustment is not valid.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='valid_commercial?'>&lt;p&gt;Do year &lt;tt&gt;y&lt;/tt&gt;, week-of-year &lt;tt&gt;w&lt;/tt&gt;, and day-of-week &lt;tt&gt;d&lt;/tt&gt; make a valid Commercial Date? Returns the corresponding Julian Day Number if they do, nil if they don&apos;t.&lt;/p&gt;&lt;p&gt;Monday is day-of-week 1; Sunday is day-of-week 7.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;w&lt;/tt&gt; and &lt;tt&gt;d&lt;/tt&gt; can be negative, in which case they count backwards from the end of the year and the end of the week respectively. No wraparound is performed, however, and invalid values cause an ArgumentError to be raised. A date falling in the period skipped in the Day of Calendar Reform adjustment is not valid.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='valid_jd?'>&lt;p&gt;Is &lt;tt&gt;jd&lt;/tt&gt; a valid Julian Day Number?&lt;/p&gt;&lt;p&gt;If it is, returns it. In fact, any value is treated as a valid Julian Day Number.&lt;/p&gt;</method>
    <method name='valid_ordinal?'>&lt;p&gt;Do the year &lt;tt&gt;y&lt;/tt&gt; and day-of-year &lt;tt&gt;d&lt;/tt&gt; make a valid Ordinal Date? Returns the corresponding Julian Day Number if they do, or nil if they don&apos;t.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;d&lt;/tt&gt; can be a negative number, in which case it counts backwards from the end of the year (-1 being the last day of the year). No year wraparound is performed, however, so valid values of &lt;tt&gt;d&lt;/tt&gt; are -365 .. -1, 1 .. 365 on a non-leap-year, -366 .. -1, 1 .. 366 on a leap year. A date falling in the period skipped in the Day of Calendar Reform adjustment is not valid.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;sg&lt;/tt&gt; specifies the Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='zone_to_diff'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='+'>&lt;p&gt;Return a new Date object that is &lt;tt&gt;n&lt;/tt&gt; days later than the current one.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;n&lt;/tt&gt; may be a negative value, in which case the new Date is earlier than the current one; however, #-() might be more intuitive.&lt;/p&gt;&lt;p&gt;If &lt;tt&gt;n&lt;/tt&gt; is not a Numeric, a TypeError will be thrown. In particular, two Dates cannot be added to each other.&lt;/p&gt;</method>
    <method name='-'>&lt;p&gt;If &lt;tt&gt;x&lt;/tt&gt; is a Numeric value, create a new Date object that is &lt;tt&gt;x&lt;/tt&gt; days earlier than the current one.&lt;/p&gt;&lt;p&gt;If &lt;tt&gt;x&lt;/tt&gt; is a Date, return the number of days between the two dates; or, more precisely, how many days later the current date is than &lt;tt&gt;x&lt;/tt&gt;.&lt;/p&gt;&lt;p&gt;If &lt;tt&gt;x&lt;/tt&gt; is neither Numeric nor a Date, a TypeError is raised.&lt;/p&gt;</method>
    <method name='&lt;&lt;'>&lt;p&gt;Return a new Date object that is &lt;tt&gt;n&lt;/tt&gt; months earlier than the current one.&lt;/p&gt;&lt;p&gt;If the day-of-the-month of the current Date is greater than the last day of the target month, the day-of-the-month of the returned Date will be the last day of the target month.&lt;/p&gt;</method>
    <method name='&lt;=&gt;'>&lt;p&gt;Compare this date with another date.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;other&lt;/tt&gt; can also be a Numeric value, in which case it is interpreted as an Astronomical Julian Day Number.&lt;/p&gt;&lt;p&gt;Comparison is by Astronomical Julian Day Number, including fractional days. This means that both the time and the timezone offset are taken into account when comparing two DateTime instances. When comparing a DateTime instance with a Date instance, the time of the latter will be considered as falling on midnight UTC.&lt;/p&gt;</method>
    <method name='==='>&lt;p&gt;The relationship operator for Date.&lt;/p&gt;&lt;p&gt;Compares dates by Julian Day Number. When comparing two DateTime instances, or a DateTime with a Date, the instances will be regarded as equivalent if they fall on the same date in local time.&lt;/p&gt;</method>
    <method name='&gt;&gt;'>&lt;p&gt;Return a new Date object that is &lt;tt&gt;n&lt;/tt&gt; months later than the current one.&lt;/p&gt;&lt;p&gt;If the day-of-the-month of the current Date is greater than the last day of the target month, the day-of-the-month of the returned Date will be the last day of the target month.&lt;/p&gt;</method>
    <method name='_dump'>&lt;p&gt;Dump to Marshal format.&lt;/p&gt;</method>
    <method name='ajd'>&lt;p&gt;Get the date as an Astronomical Julian Day Number.&lt;/p&gt;</method>
    <method name='amjd'>&lt;p&gt;Get the date as an Astronomical Modified Julian Day Number.&lt;/p&gt;</method>
    <method name='asctime'>&lt;p&gt;alias_method :format, :strftime&lt;/p&gt;</method>
    <method name='ctime'>&lt;p&gt;Alias for #asctime&lt;/p&gt;</method>
    <method name='cwday'>&lt;p&gt;Get the commercial day of the week of this date. Monday is commercial day-of-week 1; Sunday is commercial day-of-week 7.&lt;/p&gt;</method>
    <method name='cweek'>&lt;p&gt;Get the commercial week of the year of this date.&lt;/p&gt;</method>
    <method name='cwyear'>&lt;p&gt;Get the commercial year of this date. See &lt;b&gt;Commercial&lt;/b&gt; &lt;b&gt;Date&lt;/b&gt; in the introduction for how this differs from the normal year.&lt;/p&gt;</method>
    <method name='day'>&lt;p&gt;Alias for #mday&lt;/p&gt;</method>
    <method name='day_fraction'>&lt;p&gt;Get any fractional day part of the date.&lt;/p&gt;</method>
    <method name='downto'>&lt;p&gt;Step backward one day at a time until we reach &lt;tt&gt;min&lt;/tt&gt; (inclusive), yielding each date as we go.&lt;/p&gt;</method>
    <method name='england'>&lt;p&gt;Create a copy of this Date object that uses the English/Colonial Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='eql?'>&lt;p&gt;Is this Date equal to &lt;tt&gt;other&lt;/tt&gt;?&lt;/p&gt;&lt;p&gt;&lt;tt&gt;other&lt;/tt&gt; must both be a Date object, and represent the same date.&lt;/p&gt;</method>
    <method name='gregorian'>&lt;p&gt;Create a copy of this Date object that always uses the Gregorian Calendar.&lt;/p&gt;</method>
    <method name='hash'>&lt;p&gt;Calculate a hash value for this date.&lt;/p&gt;</method>
    <method name='inspect'>&lt;p&gt;Return internal object state as a programmer-readable string.&lt;/p&gt;</method>
    <method name='italy'>&lt;p&gt;Create a copy of this Date object that uses the Italian/Catholic Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='jd'>&lt;p&gt;Get the date as a Julian Day Number.&lt;/p&gt;</method>
    <method name='julian'>&lt;p&gt;Create a copy of this Date object that always uses the Julian Calendar.&lt;/p&gt;</method>
    <method name='ld'>&lt;p&gt;Get the date as the number of days since the Day of Calendar Reform (in Italy and the Catholic countries).&lt;/p&gt;</method>
    <method name='leap?'>&lt;p&gt;Is this a leap year?&lt;/p&gt;</method>
    <method name='mday'>&lt;p&gt;Get the day-of-the-month of this date.&lt;/p&gt;</method>
    <method name='mjd'>&lt;p&gt;Get the date as a Modified Julian Day Number.&lt;/p&gt;</method>
    <method name='mon'>&lt;p&gt;Get the month of this date.&lt;/p&gt;&lt;p&gt;January is month 1.&lt;/p&gt;</method>
    <method name='month'>&lt;p&gt;Alias for #mon&lt;/p&gt;</method>
    <method name='new_start'>&lt;p&gt;Create a copy of this Date object using a new Day of Calendar Reform.&lt;/p&gt;</method>
    <method name='next'>&lt;p&gt;Alias for #succ&lt;/p&gt;</method>
    <method name='ns?'>&lt;p&gt;Is the current date new-style (Gregorian Calendar)?&lt;/p&gt;</method>
    <method name='os?'>&lt;p&gt;Is the current date old-style (Julian Calendar)?&lt;/p&gt;</method>
    <method name='start'>&lt;p&gt;When is the Day of Calendar Reform for this Date object?&lt;/p&gt;</method>
    <method name='step'>&lt;p&gt;Step the current date forward &lt;tt&gt;step&lt;/tt&gt; days at a time (or backward, if &lt;tt&gt;step&lt;/tt&gt; is negative) until we reach &lt;tt&gt;limit&lt;/tt&gt; (inclusive), yielding the resultant date at each step.&lt;/p&gt;</method>
    <method name='strftime'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='succ'>&lt;p&gt;Return a new Date one day after this one.&lt;/p&gt;</method>
    <method name='to_s'>&lt;p&gt;Return the date as a human-readable string.&lt;/p&gt;&lt;p&gt;The format used is YYYY-MM-DD.&lt;/p&gt;</method>
    <method name='to_yaml'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='upto'>&lt;p&gt;Step forward one day at a time until we reach &lt;tt&gt;max&lt;/tt&gt; (inclusive), yielding each date as we go.&lt;/p&gt;</method>
    <method name='wday'>&lt;p&gt;Get the week day of this date. Sunday is day-of-week 0; Saturday is day-of-week 6.&lt;/p&gt;</method>
    <method name='yday'>&lt;p&gt;Get the day-of-the-year of this date.&lt;/p&gt;&lt;p&gt;January 1 is day-of-the-year 1&lt;/p&gt;</method>
    <method name='year'>&lt;p&gt;Get the year of this date.&lt;/p&gt;</method>
  </methods>
</help>