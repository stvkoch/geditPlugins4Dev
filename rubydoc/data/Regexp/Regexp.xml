<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<help>
  <comment>&lt;p&gt;Document-class: Regexp&lt;/p&gt;&lt;p&gt;A &lt;tt&gt;Regexp&lt;/tt&gt; holds a regular expression, used to match a pattern against strings. Regexps are created using the &lt;tt&gt;/.../&lt;/tt&gt; and &lt;tt&gt;%r{...}&lt;/tt&gt; literals, and by the &lt;tt&gt;Regexp::new&lt;/tt&gt; constructor.&lt;/p&gt;</comment>
  <methods>
    <method name='compile'>&lt;p&gt;Synonym for &lt;tt&gt;Regexp.new&lt;/tt&gt;&lt;/p&gt;</method>
    <method name='escape'>&lt;p&gt;Escapes any characters that would have special meaning in a regular expression. Returns a new escaped string, or self if no characters are escaped. For any string, &lt;tt&gt;Regexp.escape(&lt;em&gt;str&lt;/em&gt;)=~&lt;em&gt;str&lt;/em&gt;&lt;/tt&gt; will be true.&lt;/p&gt;&lt;pre&gt;   Regexp.escape(&apos;\*?{}.&apos;)   #=&gt; \\*\?\{\}\.
&lt;/pre&gt;</method>
    <method name='last_match'>&lt;p&gt;The first form returns the &lt;tt&gt;MatchData&lt;/tt&gt; object generated by the last successful pattern match. Equivalent to reading the global variable &lt;tt&gt;$~&lt;/tt&gt;. The second form returns the nth field in this &lt;tt&gt;MatchData&lt;/tt&gt; object.&lt;/p&gt;&lt;pre&gt;   /c(.)t/ =~ &apos;cat&apos;       #=&gt; 0
   Regexp.last_match      #=&gt; #&lt;MatchData:0x401b3d30&gt;
   Regexp.last_match(0)   #=&gt; &quot;cat&quot;
   Regexp.last_match(1)   #=&gt; &quot;a&quot;
   Regexp.last_match(2)   #=&gt; nil
&lt;/pre&gt;</method>
    <method name='new'>&lt;p&gt;Constructs a new regular expression from &lt;em&gt;pattern&lt;/em&gt;, which can be either a &lt;tt&gt;String&lt;/tt&gt; or a &lt;tt&gt;Regexp&lt;/tt&gt; (in which case that regexp&apos;s options are propagated, and new options may not be specified (a change as of Ruby 1.8). If &lt;em&gt;options&lt;/em&gt; is a &lt;tt&gt;Fixnum&lt;/tt&gt;, it should be one or more of the constants &lt;tt&gt;Regexp::EXTENDED&lt;/tt&gt;, &lt;tt&gt;Regexp::IGNORECASE&lt;/tt&gt;, and &lt;tt&gt;Regexp::MULTILINE&lt;/tt&gt;, &lt;em&gt;or&lt;/em&gt;-ed together. Otherwise, if &lt;em&gt;options&lt;/em&gt; is not &lt;tt&gt;nil&lt;/tt&gt;, the regexp will be case insensitive. The &lt;em&gt;lang&lt;/em&gt; parameter enables multibyte support for the regexp: `n&apos;, `N&apos; = none, `e&apos;, `E&apos; = EUC, `s&apos;, `S&apos; = SJIS, `u&apos;, `U&apos; = UTF-8.&lt;/p&gt;&lt;pre&gt;   r1 = Regexp.new(&apos;^a-z+:\s+\w+&apos;)           #=&gt; /^a-z+:\s+\w+/
   r2 = Regexp.new(&apos;cat&apos;, true)               #=&gt; /cat/i
   r3 = Regexp.new(&apos;dog&apos;, Regexp::EXTENDED)   #=&gt; /dog/x
   r4 = Regexp.new(r2)                        #=&gt; /cat/i
&lt;/pre&gt;</method>
    <method name='quote'>&lt;p&gt;Escapes any characters that would have special meaning in a regular expression. Returns a new escaped string, or self if no characters are escaped. For any string, &lt;tt&gt;Regexp.escape(&lt;em&gt;str&lt;/em&gt;)=~&lt;em&gt;str&lt;/em&gt;&lt;/tt&gt; will be true.&lt;/p&gt;&lt;pre&gt;   Regexp.escape(&apos;\*?{}.&apos;)   #=&gt; \\*\?\{\}\.
&lt;/pre&gt;</method>
    <method name='union'>&lt;p&gt;Return a &lt;tt&gt;Regexp&lt;/tt&gt; object that is the union of the given &lt;em&gt;pattern&lt;/em&gt;s, i.e., will match any of its parts. The &lt;em&gt;pattern&lt;/em&gt;s can be Regexp objects, in which case their options will be preserved, or Strings. If no arguments are given, returns &lt;tt&gt;/(?!)/&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   Regexp.union                         #=&gt; /(?!)/
   Regexp.union(&quot;penzance&quot;)             #=&gt; /penzance/
   Regexp.union(&quot;skiing&quot;, &quot;sledding&quot;)   #=&gt; /skiing|sledding/
   Regexp.union(/dogs/, /cats/i)        #=&gt; /(?-mix:dogs)|(?i-mx:cats)/
&lt;/pre&gt;</method>
    <method name='yaml_new'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='&amp;'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='=='>&lt;p&gt;Equality---Two regexps are equal if their patterns are identical, they have the same character set code, and their &lt;tt&gt;casefold?&lt;/tt&gt; values are the same.&lt;/p&gt;&lt;pre&gt;   /abc/  == /abc/x   #=&gt; false
   /abc/  == /abc/i   #=&gt; false
   /abc/u == /abc/n   #=&gt; false
&lt;/pre&gt;</method>
    <method name='==='>&lt;p&gt;Case Equality---Synonym for &lt;tt&gt;Regexp#=~&lt;/tt&gt; used in case statements.&lt;/p&gt;&lt;pre&gt;   a = &quot;HELLO&quot;
   case a
   when /^[a-z]*$/; print &quot;Lower case\n&quot;
   when /^[A-Z]*$/; print &quot;Upper case\n&quot;
   else;            print &quot;Mixed case\n&quot;
   end
&lt;/pre&gt;&lt;p&gt;&lt;em&gt;produces:&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;   Upper case
&lt;/pre&gt;</method>
    <method name='=~'>&lt;p&gt;Returns a &lt;tt&gt;MatchData&lt;/tt&gt; object describing the match, or &lt;tt&gt;nil&lt;/tt&gt; if there was no match. This is equivalent to retrieving the value of the special variable &lt;tt&gt;$~&lt;/tt&gt; following a normal match.&lt;/p&gt;&lt;pre&gt;   /(.)(.)(.)/.match(&quot;abc&quot;)[2]   #=&gt; &quot;b&quot;
&lt;/pre&gt;</method>
    <method name='casefold?'>&lt;p&gt;Returns the value of the case-insensitive flag.&lt;/p&gt;</method>
    <method name='eql?'>&lt;p&gt;Equality---Two regexps are equal if their patterns are identical, they have the same character set code, and their &lt;tt&gt;casefold?&lt;/tt&gt; values are the same.&lt;/p&gt;&lt;pre&gt;   /abc/  == /abc/x   #=&gt; false
   /abc/  == /abc/i   #=&gt; false
   /abc/u == /abc/n   #=&gt; false
&lt;/pre&gt;</method>
    <method name='hash'>&lt;p&gt;Produce a hash based on the text and options of this regular expression.&lt;/p&gt;</method>
    <method name='inspect'>&lt;p&gt;Produce a nicely formatted string-version of &lt;em&gt;rxp&lt;/em&gt;. Perhaps surprisingly, &lt;tt&gt;#inspect&lt;/tt&gt; actually produces the more natural version of the string than &lt;tt&gt;#to_s&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;    /ab+c/ix.to_s         #=&gt; /ab+c/ix
&lt;/pre&gt;</method>
    <method name='kcode'>&lt;p&gt;Returns the character set code for the regexp.&lt;/p&gt;</method>
    <method name='match'>&lt;p&gt;Returns a &lt;tt&gt;MatchData&lt;/tt&gt; object describing the match, or &lt;tt&gt;nil&lt;/tt&gt; if there was no match. This is equivalent to retrieving the value of the special variable &lt;tt&gt;$~&lt;/tt&gt; following a normal match.&lt;/p&gt;&lt;pre&gt;   /(.)(.)(.)/.match(&quot;abc&quot;)[2]   #=&gt; &quot;b&quot;
&lt;/pre&gt;</method>
    <method name='options'>&lt;p&gt;Returns the set of bits corresponding to the options used when creating this Regexp (see &lt;tt&gt;Regexp::new&lt;/tt&gt; for details. Note that additional bits may be set in the returned options: these are used internally by the regular expression code. These extra bits are ignored if the options are passed to &lt;tt&gt;Regexp::new&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   Regexp::IGNORECASE                  #=&gt; 1
   Regexp::EXTENDED                    #=&gt; 2
   Regexp::MULTILINE                   #=&gt; 4

   /cat/.options                       #=&gt; 128
   /cat/ix.options                     #=&gt; 131
   Regexp.new(&apos;cat&apos;, true).options     #=&gt; 129
   Regexp.new(&apos;cat&apos;, 0, &apos;s&apos;).options   #=&gt; 384

   r = /cat/ix
   Regexp.new(r.source, r.options)     #=&gt; /cat/ix
&lt;/pre&gt;</method>
    <method name='source'>&lt;p&gt;Returns the original string of the pattern.&lt;/p&gt;&lt;pre&gt;   /ab+c/ix.source   #=&gt; &quot;ab+c&quot;
&lt;/pre&gt;</method>
    <method name='to_s'>&lt;p&gt;Returns a string containing the regular expression and its options (using the &lt;tt&gt;(?xxx:yyy)&lt;/tt&gt; notation. This string can be fed back in to &lt;tt&gt;Regexp::new&lt;/tt&gt; to a regular expression with the same semantics as the original. (However, &lt;tt&gt;Regexp#==&lt;/tt&gt; may not return true when comparing the two, as the source of the regular expression itself may differ, as the example shows). &lt;tt&gt;Regexp#inspect&lt;/tt&gt; produces a generally more readable version of &lt;em&gt;rxp&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;   r1 = /ab+c/ix         #=&gt; /ab+c/ix
   s1 = r1.to_s          #=&gt; &quot;(?ix-m:ab+c)&quot;
   r2 = Regexp.new(s1)   #=&gt; /(?ix-m:ab+c)/
   r1 == r2              #=&gt; false
   r1.source             #=&gt; &quot;ab+c&quot;
   r2.source             #=&gt; &quot;(?ix-m:ab+c)&quot;
&lt;/pre&gt;</method>
    <method name='to_yaml'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='|'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='~'>&lt;p&gt;Match---Matches &lt;em&gt;rxp&lt;/em&gt; against the contents of &lt;tt&gt;$_&lt;/tt&gt;. Equivalent to &lt;tt&gt;&lt;em&gt;rxp&lt;/em&gt; =~ $_&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   $_ = &quot;input data&quot;
   ~ /at/   #=&gt; 7
&lt;/pre&gt;</method>
  </methods>
</help>