<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<help>
  <comment>&lt;p&gt;Arrays are ordered, integer-indexed collections of any object. Array indexing starts at 0, as in C or Java. A negative index is assumed to be relative to the end of the array---that is, an index of -1 indicates the last element of the array, -2 is the next to last element in the array, and so on.&lt;/p&gt;</comment>
  <methods>
    <method name='[]'>&lt;p&gt;Returns a new array populated with the given objects.&lt;/p&gt;&lt;pre&gt;  Array.[]( 1, &apos;a&apos;, /^A/ )
  Array[ 1, &apos;a&apos;, /^A/ ]
  [ 1, &apos;a&apos;, /^A/ ]
&lt;/pre&gt;</method>
    <method name='new'>&lt;p&gt;Returns a new array. In the first form, the new array is empty. In the second it is created with &lt;em&gt;size&lt;/em&gt; copies of &lt;em&gt;obj&lt;/em&gt; (that is, &lt;em&gt;size&lt;/em&gt; references to the same &lt;em&gt;obj&lt;/em&gt;). The third form creates a copy of the array passed as a parameter (the array is generated by calling to_ary on the parameter). In the last form, an array of the given size is created. Each element in this array is calculated by passing the element&apos;s index to the given block and storing the return value.&lt;/p&gt;&lt;pre&gt;   Array.new
   Array.new(2)
   Array.new(5, &quot;A&quot;)

   # only one copy of the object is created
   a = Array.new(2, Hash.new)
   a[0][&apos;cat&apos;] = &apos;feline&apos;
   a
   a[1][&apos;cat&apos;] = &apos;Felix&apos;
   a

   # here multiple copies are created
   a = Array.new(2) { Hash.new }
   a[0][&apos;cat&apos;] = &apos;feline&apos;
   a

   squares = Array.new(5) {|i| i*i}
   squares

   copy = Array.new(squares)
&lt;/pre&gt;</method>
    <method name='&amp;'>&lt;p&gt;Set Intersection---Returns a new array containing elements common to the two arrays, with no duplicates.&lt;/p&gt;&lt;pre&gt;   [ 1, 1, 3, 5 ] &amp; [ 1, 2, 3 ]   #=&gt; [ 1, 3 ]
&lt;/pre&gt;</method>
    <method name='*'>&lt;p&gt;Repetition---With a String argument, equivalent to self.join(str). Otherwise, returns a new array built by concatenating the &lt;em&gt;int&lt;/em&gt; copies of &lt;em&gt;self&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;   [ 1, 2, 3 ] * 3    #=&gt; [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
   [ 1, 2, 3 ] * &quot;,&quot;  #=&gt; &quot;1,2,3&quot;
&lt;/pre&gt;</method>
    <method name='+'>&lt;p&gt;Concatenation---Returns a new array built by concatenating the two arrays together to produce a third array.&lt;/p&gt;&lt;pre&gt;   [ 1, 2, 3 ] + [ 4, 5 ]    #=&gt; [ 1, 2, 3, 4, 5 ]
&lt;/pre&gt;</method>
    <method name='-'>&lt;p&gt;Array Difference---Returns a new array that is a copy of the original array, removing any items that also appear in other_array. (If you need set-like behavior, see the library class Set.)&lt;/p&gt;&lt;pre&gt;   [ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  #=&gt;  [ 3, 3, 5 ]
&lt;/pre&gt;</method>
    <method name='&lt;&lt;'>&lt;p&gt;Append---Pushes the given object on to the end of this array. This expression returns the array itself, so several appends may be chained together.&lt;/p&gt;&lt;pre&gt;   [ 1, 2 ] &lt;&lt; &quot;c&quot; &lt;&lt; &quot;d&quot; &lt;&lt; [ 3, 4 ]
           #=&gt;  [ 1, 2, &quot;c&quot;, &quot;d&quot;, [ 3, 4 ] ]
&lt;/pre&gt;</method>
    <method name='&lt;=&gt;'>&lt;p&gt;Comparison---Returns an integer (-1, 0, or +1) if this array is less than, equal to, or greater than other_array. Each object in each array is compared (using &lt;=&gt;). If any value isn&apos;t equal, then that inequality is the return value. If all the values found are equal, then the return is based on a comparison of the array lengths. Thus, two arrays are ``equal&apos;&apos; according to &lt;tt&gt;Array#&lt;=&gt;&lt;/tt&gt; if and only if they have the same length and the value of each element is equal to the value of the corresponding element in the other array.&lt;/p&gt;&lt;pre&gt;   [ &quot;a&quot;, &quot;a&quot;, &quot;c&quot; ]    &lt;=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]   #=&gt; -1
   [ 1, 2, 3, 4, 5, 6 ] &lt;=&gt; [ 1, 2 ]            #=&gt; +1
&lt;/pre&gt;</method>
    <method name='=='>&lt;p&gt;Equality---Two arrays are equal if they contain the same number of elements and if each element is equal to (according to Object.==) the corresponding element in the other array.&lt;/p&gt;&lt;pre&gt;   [ &quot;a&quot;, &quot;c&quot; ]    == [ &quot;a&quot;, &quot;c&quot;, 7 ]     #=&gt; false
   [ &quot;a&quot;, &quot;c&quot;, 7 ] == [ &quot;a&quot;, &quot;c&quot;, 7 ]     #=&gt; true
   [ &quot;a&quot;, &quot;c&quot;, 7 ] == [ &quot;a&quot;, &quot;d&quot;, &quot;f&quot; ]   #=&gt; false
&lt;/pre&gt;</method>
    <method name='[]'>&lt;p&gt;Element Reference---Returns the element at &lt;em&gt;index&lt;/em&gt;, or returns a subarray starting at &lt;em&gt;start&lt;/em&gt; and continuing for &lt;em&gt;length&lt;/em&gt; elements, or returns a subarray specified by &lt;em&gt;range&lt;/em&gt;. Negative indices count backward from the end of the array (-1 is the last element). Returns nil if the index (or starting index) are out of range.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   a[2] +  a[0] + a[1]    #=&gt; &quot;cab&quot;
   a[6]                   #=&gt; nil
   a[1, 2]                #=&gt; [ &quot;b&quot;, &quot;c&quot; ]
   a[1..3]                #=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a[4..7]                #=&gt; [ &quot;e&quot; ]
   a[6..10]               #=&gt; nil
   a[-3, 3]               #=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   # special cases
   a[5]                   #=&gt; nil
   a[5, 1]                #=&gt; []
   a[5..10]               #=&gt; []
&lt;/pre&gt;</method>
    <method name='[]='>&lt;p&gt;Element Assignment---Sets the element at &lt;em&gt;index&lt;/em&gt;, or replaces a subarray starting at &lt;em&gt;start&lt;/em&gt; and continuing for &lt;em&gt;length&lt;/em&gt; elements, or replaces a subarray specified by &lt;em&gt;range&lt;/em&gt;. If indices are greater than the current capacity of the array, the array grows automatically. A negative indices will count backward from the end of the array. Inserts elements if &lt;em&gt;length&lt;/em&gt; is zero. If &lt;tt&gt;nil&lt;/tt&gt; is used in the second and third form, deletes elements from &lt;em&gt;self&lt;/em&gt;. An &lt;tt&gt;IndexError&lt;/tt&gt; is raised if a negative index points past the beginning of the array. See also &lt;tt&gt;Array#push&lt;/tt&gt;, and &lt;tt&gt;Array#unshift&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   a = Array.new
   a[4] = &quot;4&quot;;                 #=&gt; [nil, nil, nil, nil, &quot;4&quot;]
   a[0, 3] = [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ] #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, nil, &quot;4&quot;]
   a[1..2] = [ 1, 2 ]          #=&gt; [&quot;a&quot;, 1, 2, nil, &quot;4&quot;]
   a[0, 2] = &quot;?&quot;               #=&gt; [&quot;?&quot;, 2, nil, &quot;4&quot;]
   a[0..2] = &quot;A&quot;               #=&gt; [&quot;A&quot;, &quot;4&quot;]
   a[-1]   = &quot;Z&quot;               #=&gt; [&quot;A&quot;, &quot;Z&quot;]
   a[1..-1] = nil              #=&gt; [&quot;A&quot;]
&lt;/pre&gt;</method>
    <method name='abbrev'>&lt;p&gt;Calculates the set of unambiguous abbreviations for the strings in &lt;tt&gt;self&lt;/tt&gt;. If passed a pattern or a string, only the strings matching the pattern or starting with the string are considered.&lt;/p&gt;&lt;pre&gt;  %w{ car cone }.abbrev   #=&gt; { &quot;ca&quot; =&gt; &quot;car&quot;, &quot;car&quot; =&gt; &quot;car&quot;,
                                &quot;co&quot; =&gt; &quot;cone&quot;, &quot;con&quot; =&gt; cone&quot;,
                                &quot;cone&quot; =&gt; &quot;cone&quot; }
&lt;/pre&gt;</method>
    <method name='assoc'>&lt;p&gt;Searches through an array whose elements are also arrays comparing &lt;em&gt;obj&lt;/em&gt; with the first element of each contained array using obj.==. Returns the first contained array that matches (that is, the first associated array), or &lt;tt&gt;nil&lt;/tt&gt; if no match is found. See also &lt;tt&gt;Array#rassoc&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   s1 = [ &quot;colors&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot; ]
   s2 = [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   s3 = &quot;foo&quot;
   a  = [ s1, s2, s3 ]
   a.assoc(&quot;letters&quot;)  #=&gt; [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.assoc(&quot;foo&quot;)      #=&gt; nil
&lt;/pre&gt;</method>
    <method name='at'>&lt;p&gt;Returns the element at &lt;em&gt;index&lt;/em&gt;. A negative index counts from the end of &lt;em&gt;self&lt;/em&gt;. Returns &lt;tt&gt;nil&lt;/tt&gt; if the index is out of range. See also &lt;tt&gt;Array#[]&lt;/tt&gt;. (&lt;tt&gt;Array#at&lt;/tt&gt; is slightly faster than &lt;tt&gt;Array#[]&lt;/tt&gt;, as it does not accept ranges and so on.)&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   a.at(0)     #=&gt; &quot;a&quot;
   a.at(-1)    #=&gt; &quot;e&quot;
&lt;/pre&gt;</method>
    <method name='clear'>&lt;p&gt;Removes all elements from &lt;em&gt;self&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   a.clear    #=&gt; [ ]
&lt;/pre&gt;</method>
    <method name='collect'>&lt;p&gt;Invokes &lt;em&gt;block&lt;/em&gt; once for each element of &lt;em&gt;self&lt;/em&gt;. Creates a new array containing the values returned by the block. See also &lt;tt&gt;Enumerable#collect&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.collect {|x| x + &quot;!&quot; }   #=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]
   a                          #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
&lt;/pre&gt;</method>
    <method name='collect!'>&lt;p&gt;Invokes the block once for each element of &lt;em&gt;self&lt;/em&gt;, replacing the element with the value returned by &lt;em&gt;block&lt;/em&gt;. See also &lt;tt&gt;Enumerable#collect&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.collect! {|x| x + &quot;!&quot; }
   a             #=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]
&lt;/pre&gt;</method>
    <method name='compact'>&lt;p&gt;Returns a copy of &lt;em&gt;self&lt;/em&gt; with all &lt;tt&gt;nil&lt;/tt&gt; elements removed.&lt;/p&gt;&lt;pre&gt;   [ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot;, nil ].compact
                     #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
&lt;/pre&gt;</method>
    <method name='compact!'>&lt;p&gt;Removes &lt;tt&gt;nil&lt;/tt&gt; elements from array. Returns &lt;tt&gt;nil&lt;/tt&gt; if no changes were made.&lt;/p&gt;&lt;pre&gt;   [ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot; ].compact! #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].compact!           #=&gt; nil
&lt;/pre&gt;</method>
    <method name='concat'>&lt;p&gt;Appends the elements in other_array to &lt;em&gt;self&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;   [ &quot;a&quot;, &quot;b&quot; ].concat( [&quot;c&quot;, &quot;d&quot;] ) #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
&lt;/pre&gt;</method>
    <method name='dclone'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='delete'>&lt;p&gt;Deletes items from &lt;em&gt;self&lt;/em&gt; that are equal to &lt;em&gt;obj&lt;/em&gt;. If the item is not found, returns &lt;tt&gt;nil&lt;/tt&gt;. If the optional code block is given, returns the result of &lt;em&gt;block&lt;/em&gt; if the item is not found.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.delete(&quot;b&quot;)                   #=&gt; &quot;b&quot;
   a                               #=&gt; [&quot;a&quot;, &quot;c&quot;]
   a.delete(&quot;z&quot;)                   #=&gt; nil
   a.delete(&quot;z&quot;) { &quot;not found&quot; }   #=&gt; &quot;not found&quot;
&lt;/pre&gt;</method>
    <method name='delete_at'>&lt;p&gt;Deletes the element at the specified index, returning that element, or &lt;tt&gt;nil&lt;/tt&gt; if the index is out of range. See also &lt;tt&gt;Array#slice!&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   a = %w( ant bat cat dog )
   a.delete_at(2)    #=&gt; &quot;cat&quot;
   a                 #=&gt; [&quot;ant&quot;, &quot;bat&quot;, &quot;dog&quot;]
   a.delete_at(99)   #=&gt; nil
&lt;/pre&gt;</method>
    <method name='delete_if'>&lt;p&gt;Deletes every element of &lt;em&gt;self&lt;/em&gt; for which &lt;em&gt;block&lt;/em&gt; evaluates to &lt;tt&gt;true&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.delete_if {|x| x &gt;= &quot;b&quot; }   #=&gt; [&quot;a&quot;]
&lt;/pre&gt;</method>
    <method name='each'>&lt;p&gt;Calls &lt;em&gt;block&lt;/em&gt; once for each element in &lt;em&gt;self&lt;/em&gt;, passing that element as a parameter.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.each {|x| print x, &quot; -- &quot; }
&lt;/pre&gt;&lt;p&gt;produces:&lt;/p&gt;&lt;pre&gt;   a -- b -- c --
&lt;/pre&gt;</method>
    <method name='each_index'>&lt;p&gt;Same as &lt;tt&gt;Array#each&lt;/tt&gt;, but passes the index of the element instead of the element itself.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.each_index {|x| print x, &quot; -- &quot; }
&lt;/pre&gt;&lt;p&gt;produces:&lt;/p&gt;&lt;pre&gt;   0 -- 1 -- 2 --
&lt;/pre&gt;</method>
    <method name='empty?'>&lt;p&gt;Returns &lt;tt&gt;true&lt;/tt&gt; if &lt;em&gt;self&lt;/em&gt; array contains no elements.&lt;/p&gt;&lt;pre&gt;   [].empty?   #=&gt; true
&lt;/pre&gt;</method>
    <method name='eql?'>&lt;p&gt;Returns &lt;tt&gt;true&lt;/tt&gt; if &lt;em&gt;array&lt;/em&gt; and &lt;em&gt;other&lt;/em&gt; are the same object, or are both arrays with the same content.&lt;/p&gt;</method>
    <method name='fetch'>&lt;p&gt;Tries to return the element at position &lt;em&gt;index&lt;/em&gt;. If the index lies outside the array, the first form throws an &lt;tt&gt;IndexError&lt;/tt&gt; exception, the second form returns &lt;em&gt;default&lt;/em&gt;, and the third form returns the value of invoking the block, passing in the index. Negative values of &lt;em&gt;index&lt;/em&gt; count from the end of the array.&lt;/p&gt;&lt;pre&gt;   a = [ 11, 22, 33, 44 ]
   a.fetch(1)               #=&gt; 22
   a.fetch(-1)              #=&gt; 44
   a.fetch(4, &apos;cat&apos;)        #=&gt; &quot;cat&quot;
   a.fetch(4) { |i| i*i }   #=&gt; 16
&lt;/pre&gt;</method>
    <method name='fill'>&lt;p&gt;The first three forms set the selected elements of &lt;em&gt;self&lt;/em&gt; (which may be the entire array) to &lt;em&gt;obj&lt;/em&gt;. A &lt;em&gt;start&lt;/em&gt; of &lt;tt&gt;nil&lt;/tt&gt; is equivalent to zero. A &lt;em&gt;length&lt;/em&gt; of &lt;tt&gt;nil&lt;/tt&gt; is equivalent to &lt;em&gt;self.length&lt;/em&gt;. The last three forms fill the array with the value of the block. The block is passed the absolute index of each element to be filled.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.fill(&quot;x&quot;)              #=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]
   a.fill(&quot;z&quot;, 2, 2)        #=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;z&quot;, &quot;z&quot;]
   a.fill(&quot;y&quot;, 0..1)        #=&gt; [&quot;y&quot;, &quot;y&quot;, &quot;z&quot;, &quot;z&quot;]
   a.fill {|i| i*i}         #=&gt; [0, 1, 4, 9]
   a.fill(-2) {|i| i*i*i}   #=&gt; [0, 1, 8, 27]
&lt;/pre&gt;</method>
    <method name='first'>&lt;p&gt;Returns the first element, or the first &lt;tt&gt;n&lt;/tt&gt; elements, of the array. If the array is empty, the first form returns &lt;tt&gt;nil&lt;/tt&gt;, and the second form returns an empty array.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot; ]
   a.first    #=&gt; &quot;q&quot;
   a.first(1) #=&gt; [&quot;q&quot;]
   a.first(3) #=&gt; [&quot;q&quot;, &quot;r&quot;, &quot;s&quot;]
&lt;/pre&gt;</method>
    <method name='flatten'>&lt;p&gt;Returns a new array that is a one-dimensional flattening of this array (recursively). That is, for every element that is an array, extract its elements into the new array.&lt;/p&gt;&lt;pre&gt;   s = [ 1, 2, 3 ]           #=&gt; [1, 2, 3]
   t = [ 4, 5, 6, [7, 8] ]   #=&gt; [4, 5, 6, [7, 8]]
   a = [ s, t, 9, 10 ]       #=&gt; [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
   a.flatten                 #=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10
&lt;/pre&gt;</method>
    <method name='flatten!'>&lt;p&gt;Flattens &lt;em&gt;self&lt;/em&gt; in place. Returns &lt;tt&gt;nil&lt;/tt&gt; if no modifications were made (i.e., &lt;em&gt;array&lt;/em&gt; contains no subarrays.)&lt;/p&gt;&lt;pre&gt;   a = [ 1, 2, [3, [4, 5] ] ]
   a.flatten!   #=&gt; [1, 2, 3, 4, 5]
   a.flatten!   #=&gt; nil
   a            #=&gt; [1, 2, 3, 4, 5]
&lt;/pre&gt;</method>
    <method name='frozen?'>&lt;p&gt;Return &lt;tt&gt;true&lt;/tt&gt; if this array is frozen (or temporarily frozen while being sorted).&lt;/p&gt;</method>
    <method name='hash'>&lt;p&gt;Compute a hash-code for this array. Two arrays with the same content will have the same hash code (and will compare using &lt;tt&gt;eql?&lt;/tt&gt;).&lt;/p&gt;</method>
    <method name='include?'>&lt;p&gt;Returns &lt;tt&gt;true&lt;/tt&gt; if the given object is present in &lt;em&gt;self&lt;/em&gt; (that is, if any object &lt;tt&gt;==&lt;/tt&gt; &lt;em&gt;anObject&lt;/em&gt;), &lt;tt&gt;false&lt;/tt&gt; otherwise.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.include?(&quot;b&quot;)   #=&gt; true
   a.include?(&quot;z&quot;)   #=&gt; false
&lt;/pre&gt;</method>
    <method name='index'>&lt;p&gt;Returns the index of the first object in &lt;em&gt;self&lt;/em&gt; such that is &lt;tt&gt;==&lt;/tt&gt; to &lt;em&gt;obj&lt;/em&gt;. Returns &lt;tt&gt;nil&lt;/tt&gt; if no match is found.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.index(&quot;b&quot;)   #=&gt; 1
   a.index(&quot;z&quot;)   #=&gt; nil
&lt;/pre&gt;</method>
    <method name='indexes'>&lt;p&gt;Deprecated; use &lt;tt&gt;Array#values_at&lt;/tt&gt;.&lt;/p&gt;</method>
    <method name='indices'>&lt;p&gt;Deprecated; use &lt;tt&gt;Array#values_at&lt;/tt&gt;.&lt;/p&gt;</method>
    <method name='initialize_copy'>&lt;p&gt;Replaces the contents of &lt;em&gt;self&lt;/em&gt; with the contents of &lt;em&gt;other_array&lt;/em&gt;, truncating or expanding if necessary.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   a.replace([ &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ])   #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
   a                              #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
&lt;/pre&gt;</method>
    <method name='insert'>&lt;p&gt;Inserts the given values before the element with the given index (which may be negative).&lt;/p&gt;&lt;pre&gt;   a = %w{ a b c d }
   a.insert(2, 99)         #=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, &quot;d&quot;]
   a.insert(-2, 1, 2, 3)   #=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, 1, 2, 3, &quot;d&quot;]
&lt;/pre&gt;</method>
    <method name='inspect'>&lt;p&gt;Create a printable version of &lt;em&gt;array&lt;/em&gt;.&lt;/p&gt;</method>
    <method name='join'>&lt;p&gt;Returns a string created by converting each element of the array to a string, separated by &lt;em&gt;sep&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join        #=&gt; &quot;abc&quot;
   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join(&quot;-&quot;)   #=&gt; &quot;a-b-c&quot;
&lt;/pre&gt;</method>
    <method name='last'>&lt;p&gt;Returns the last element(s) of &lt;em&gt;self&lt;/em&gt;. If the array is empty, the first form returns &lt;tt&gt;nil&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   [ &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ].last   #=&gt; &quot;z&quot;
&lt;/pre&gt;</method>
    <method name='length'>&lt;p&gt;Returns the number of elements in &lt;em&gt;self&lt;/em&gt;. May be zero.&lt;/p&gt;&lt;pre&gt;   [ 1, 2, 3, 4, 5 ].length   #=&gt; 5
&lt;/pre&gt;</method>
    <method name='map'>&lt;p&gt;Invokes &lt;em&gt;block&lt;/em&gt; once for each element of &lt;em&gt;self&lt;/em&gt;. Creates a new array containing the values returned by the block. See also &lt;tt&gt;Enumerable#collect&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.collect {|x| x + &quot;!&quot; }   #=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]
   a                          #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
&lt;/pre&gt;</method>
    <method name='map!'>&lt;p&gt;Invokes the block once for each element of &lt;em&gt;self&lt;/em&gt;, replacing the element with the value returned by &lt;em&gt;block&lt;/em&gt;. See also &lt;tt&gt;Enumerable#collect&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.collect! {|x| x + &quot;!&quot; }
   a             #=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]
&lt;/pre&gt;</method>
    <method name='nitems'>&lt;p&gt;Returns the number of non-&lt;tt&gt;nil&lt;/tt&gt; elements in &lt;em&gt;self&lt;/em&gt;. May be zero.&lt;/p&gt;&lt;pre&gt;   [ 1, nil, 3, nil, 5 ].nitems   #=&gt; 3
&lt;/pre&gt;</method>
    <method name='pack'>&lt;p&gt;Packs the contents of &lt;em&gt;arr&lt;/em&gt; into a binary sequence according to the directives in &lt;em&gt;aTemplateString&lt;/em&gt; (see the table below) Directives ``A,&apos;&apos; ``a,&apos;&apos; and ``Z&apos;&apos; may be followed by a count, which gives the width of the resulting field. The remaining directives also may take a count, indicating the number of array elements to convert. If the count is an asterisk (``&lt;tt&gt;*&lt;/tt&gt;&apos;&apos;), all remaining array elements will be converted. Any of the directives ``&lt;tt&gt;sSiIlL&lt;/tt&gt;&apos;&apos; may be followed by an underscore (``&lt;tt&gt;_&lt;/tt&gt;&apos;&apos;) to use the underlying platform&apos;s native size for the specified type; otherwise, they use a platform-independent size. Spaces are ignored in the template string. See also &lt;tt&gt;String#unpack&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   n = [ 65, 66, 67 ]
   a.pack(&quot;A3A3A3&quot;)   #=&gt; &quot;a  b  c  &quot;
   a.pack(&quot;a3a3a3&quot;)   #=&gt; &quot;a\000\000b\000\000c\000\000&quot;
   n.pack(&quot;ccc&quot;)      #=&gt; &quot;ABC&quot;
&lt;/pre&gt;&lt;p&gt;Directives for &lt;tt&gt;pack&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt; Directive    Meaning
 ---------------------------------------------------------------
     @     |  Moves to absolute position
     A     |  ASCII string (space padded, count is width)
     a     |  ASCII string (null padded, count is width)
     B     |  Bit string (descending bit order)
     b     |  Bit string (ascending bit order)
     C     |  Unsigned char
     c     |  Char
     D, d  |  Double-precision float, native format
     E     |  Double-precision float, little-endian byte order
     e     |  Single-precision float, little-endian byte order
     F, f  |  Single-precision float, native format
     G     |  Double-precision float, network (big-endian) byte order
     g     |  Single-precision float, network (big-endian) byte order
     H     |  Hex string (high nibble first)
     h     |  Hex string (low nibble first)
     I     |  Unsigned integer
     i     |  Integer
     L     |  Unsigned long
     l     |  Long
     M     |  Quoted printable, MIME encoding (see RFC2045)
     m     |  Base64 encoded string
     N     |  Long, network (big-endian) byte order
     n     |  Short, network (big-endian) byte-order
     P     |  Pointer to a structure (fixed-length string)
     p     |  Pointer to a null-terminated string
     Q, q  |  64-bit number
     S     |  Unsigned short
     s     |  Short
     U     |  UTF-8
     u     |  UU-encoded string
     V     |  Long, little-endian byte order
     v     |  Short, little-endian byte order
     w     |  BER-compressed integer\fnm
     X     |  Back up a byte
     x     |  Null byte
     Z     |  Same as ``a&apos;&apos;, except that null is added with *
&lt;/pre&gt;</method>
    <method name='pop'>&lt;p&gt;Removes the last element from &lt;em&gt;self&lt;/em&gt; and returns it, or &lt;tt&gt;nil&lt;/tt&gt; if the array is empty.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;m&quot;, &quot;z&quot; ]
   a.pop   #=&gt; &quot;z&quot;
   a       #=&gt; [&quot;a&quot;, &quot;m&quot;]
&lt;/pre&gt;</method>
    <method name='pretty_print'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='pretty_print_cycle'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='push'>&lt;p&gt;Append---Pushes the given object(s) on to the end of this array. This expression returns the array itself, so several appends may be chained together.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.push(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)
           #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]
&lt;/pre&gt;</method>
    <method name='quote'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='rassoc'>&lt;p&gt;Searches through the array whose elements are also arrays. Compares &lt;em&gt;key&lt;/em&gt; with the second element of each contained array using &lt;tt&gt;==&lt;/tt&gt;. Returns the first contained array that matches. See also &lt;tt&gt;Array#assoc&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   a = [ [ 1, &quot;one&quot;], [2, &quot;two&quot;], [3, &quot;three&quot;], [&quot;ii&quot;, &quot;two&quot;] ]
   a.rassoc(&quot;two&quot;)    #=&gt; [2, &quot;two&quot;]
   a.rassoc(&quot;four&quot;)   #=&gt; nil
&lt;/pre&gt;</method>
    <method name='reject'>&lt;p&gt;Returns a new array containing the items in &lt;em&gt;self&lt;/em&gt; for which the block is not true.&lt;/p&gt;</method>
    <method name='reject!'>&lt;p&gt;Equivalent to &lt;tt&gt;Array#delete_if&lt;/tt&gt;, deleting elements from &lt;em&gt;self&lt;/em&gt; for which the block evaluates to true, but returns &lt;tt&gt;nil&lt;/tt&gt; if no changes were made. Also see &lt;tt&gt;Enumerable#reject&lt;/tt&gt;.&lt;/p&gt;</method>
    <method name='replace'>&lt;p&gt;Replaces the contents of &lt;em&gt;self&lt;/em&gt; with the contents of &lt;em&gt;other_array&lt;/em&gt;, truncating or expanding if necessary.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   a.replace([ &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ])   #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
   a                              #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
&lt;/pre&gt;</method>
    <method name='reverse'>&lt;p&gt;Returns a new array containing &lt;em&gt;self&lt;/em&gt;&apos;s elements in reverse order.&lt;/p&gt;&lt;pre&gt;   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].reverse   #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
   [ 1 ].reverse               #=&gt; [1]
&lt;/pre&gt;</method>
    <method name='reverse!'>&lt;p&gt;Reverses &lt;em&gt;self&lt;/em&gt; in place.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.reverse!       #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
   a                #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
&lt;/pre&gt;</method>
    <method name='reverse_each'>&lt;p&gt;Same as &lt;tt&gt;Array#each&lt;/tt&gt;, but traverses &lt;em&gt;self&lt;/em&gt; in reverse order.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.reverse_each {|x| print x, &quot; &quot; }
&lt;/pre&gt;&lt;p&gt;produces:&lt;/p&gt;&lt;pre&gt;   c b a
&lt;/pre&gt;</method>
    <method name='rindex'>&lt;p&gt;Returns the index of the last object in &lt;em&gt;array&lt;/em&gt; &lt;tt&gt;==&lt;/tt&gt; to &lt;em&gt;obj&lt;/em&gt;. Returns &lt;tt&gt;nil&lt;/tt&gt; if no match is found.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.rindex(&quot;b&quot;)   #=&gt; 3
   a.rindex(&quot;z&quot;)   #=&gt; nil
&lt;/pre&gt;</method>
    <method name='select'>&lt;p&gt;Invokes the block passing in successive elements from &lt;em&gt;array&lt;/em&gt;, returning an array containing those elements for which the block returns a true value (equivalent to &lt;tt&gt;Enumerable#select&lt;/tt&gt;).&lt;/p&gt;&lt;pre&gt;   a = %w{ a b c d e f }
   a.select {|v| v =~ /[aeiou]/}   #=&gt; [&quot;a&quot;, &quot;e&quot;]
&lt;/pre&gt;</method>
    <method name='shift'>&lt;p&gt;Returns the first element of &lt;em&gt;self&lt;/em&gt; and removes it (shifting all other elements down by one). Returns &lt;tt&gt;nil&lt;/tt&gt; if the array is empty.&lt;/p&gt;&lt;pre&gt;   args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]
   args.shift   #=&gt; &quot;-m&quot;
   args         #=&gt; [&quot;-q&quot;, &quot;filename&quot;]
&lt;/pre&gt;</method>
    <method name='size'>&lt;p&gt;Alias for #length&lt;/p&gt;</method>
    <method name='slice'>&lt;p&gt;Element Reference---Returns the element at &lt;em&gt;index&lt;/em&gt;, or returns a subarray starting at &lt;em&gt;start&lt;/em&gt; and continuing for &lt;em&gt;length&lt;/em&gt; elements, or returns a subarray specified by &lt;em&gt;range&lt;/em&gt;. Negative indices count backward from the end of the array (-1 is the last element). Returns nil if the index (or starting index) are out of range.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   a[2] +  a[0] + a[1]    #=&gt; &quot;cab&quot;
   a[6]                   #=&gt; nil
   a[1, 2]                #=&gt; [ &quot;b&quot;, &quot;c&quot; ]
   a[1..3]                #=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a[4..7]                #=&gt; [ &quot;e&quot; ]
   a[6..10]               #=&gt; nil
   a[-3, 3]               #=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   # special cases
   a[5]                   #=&gt; nil
   a[5, 1]                #=&gt; []
   a[5..10]               #=&gt; []
&lt;/pre&gt;</method>
    <method name='slice!'>&lt;p&gt;Deletes the element(s) given by an index (optionally with a length) or by a range. Returns the deleted object, subarray, or &lt;tt&gt;nil&lt;/tt&gt; if the index is out of range. Equivalent to:&lt;/p&gt;&lt;pre&gt;   def slice!(*args)
     result = self[*args]
     self[*args] = nil
     result
   end

   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.slice!(1)     #=&gt; &quot;b&quot;
   a               #=&gt; [&quot;a&quot;, &quot;c&quot;]
   a.slice!(-1)    #=&gt; &quot;c&quot;
   a               #=&gt; [&quot;a&quot;]
   a.slice!(100)   #=&gt; nil
   a               #=&gt; [&quot;a&quot;]
&lt;/pre&gt;</method>
    <method name='sort'>&lt;p&gt;Returns a new array created by sorting &lt;em&gt;self&lt;/em&gt;. Comparisons for the sort will be done using the &lt;tt&gt;&lt;=&gt;&lt;/tt&gt; operator or using an optional code block. The block implements a comparison between &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, returning -1, 0, or +1. See also &lt;tt&gt;Enumerable#sort_by&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;, &quot;b&quot; ]
   a.sort                    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
   a.sort {|x,y| y &lt;=&gt; x }   #=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
&lt;/pre&gt;</method>
    <method name='sort!'>&lt;p&gt;Sorts &lt;em&gt;self&lt;/em&gt;. Comparisons for the sort will be done using the &lt;tt&gt;&lt;=&gt;&lt;/tt&gt; operator or using an optional code block. The block implements a comparison between &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;, returning -1, 0, or +1. See also &lt;tt&gt;Enumerable#sort_by&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;, &quot;b&quot; ]
   a.sort                    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
   a.sort {|x,y| y &lt;=&gt; x }   #=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
&lt;/pre&gt;</method>
    <method name='to_a'>&lt;p&gt;Returns &lt;em&gt;self&lt;/em&gt;. If called on a subclass of Array, converts the receiver to an Array object.&lt;/p&gt;</method>
    <method name='to_ary'>&lt;p&gt;Returns &lt;em&gt;self&lt;/em&gt;.&lt;/p&gt;</method>
    <method name='to_s'>&lt;p&gt;Returns &lt;em&gt;self&lt;/em&gt;&lt;tt&gt;.join&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   [ &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot; ].to_s   #=&gt; &quot;aeio&quot;
&lt;/pre&gt;</method>
    <method name='to_yaml'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='transpose'>&lt;p&gt;Assumes that &lt;em&gt;self&lt;/em&gt; is an array of arrays and transposes the rows and columns.&lt;/p&gt;&lt;pre&gt;   a = [[1,2], [3,4], [5,6]]
   a.transpose   #=&gt; [[1, 3, 5], [2, 4, 6]]
&lt;/pre&gt;</method>
    <method name='uniq'>&lt;p&gt;Returns a new array by removing duplicate values in &lt;em&gt;self&lt;/em&gt;.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.uniq   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&lt;/pre&gt;</method>
    <method name='uniq!'>&lt;p&gt;Removes duplicate elements from &lt;em&gt;self&lt;/em&gt;. Returns &lt;tt&gt;nil&lt;/tt&gt; if no changes are made (that is, no duplicates are found).&lt;/p&gt;&lt;pre&gt;   a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.uniq!   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   b = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   b.uniq!   #=&gt; nil
&lt;/pre&gt;</method>
    <method name='unshift'>&lt;p&gt;Prepends objects to the front of &lt;em&gt;array&lt;/em&gt;. other elements up one.&lt;/p&gt;&lt;pre&gt;   a = [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.unshift(&quot;a&quot;)   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
   a.unshift(1, 2)  #=&gt; [ 1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
&lt;/pre&gt;</method>
    <method name='values_at'>&lt;p&gt;Returns an array containing the elements in &lt;em&gt;self&lt;/em&gt; corresponding to the given selector(s). The selectors may be either integer indices or ranges. See also &lt;tt&gt;Array#select&lt;/tt&gt;.&lt;/p&gt;&lt;pre&gt;   a = %w{ a b c d e f }
   a.values_at(1, 3, 5)
   a.values_at(1, 3, 5, 7)
   a.values_at(-1, -3, -5, -7)
   a.values_at(1..3, 2...5)
&lt;/pre&gt;</method>
    <method name='yaml_initialize'>&lt;p&gt;No description for this element&lt;/p&gt;</method>
    <method name='zip'>&lt;p&gt;Converts any arguments to arrays, then merges elements of &lt;em&gt;self&lt;/em&gt; with corresponding elements from each argument. This generates a sequence of &lt;tt&gt;self.size&lt;/tt&gt; &lt;em&gt;n&lt;/em&gt;-element arrays, where &lt;em&gt;n&lt;/em&gt; is one more that the count of arguments. If the size of any argument is less than &lt;tt&gt;enumObj.size&lt;/tt&gt;, &lt;tt&gt;nil&lt;/tt&gt; values are supplied. If a block given, it is invoked for each output array, otherwise an array of arrays is returned.&lt;/p&gt;&lt;pre&gt;   a = [ 4, 5, 6 ]
   b = [ 7, 8, 9 ]

   [1,2,3].zip(a, b)      #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
   [1,2].zip(a,b)         #=&gt; [[1, 4, 7], [2, 5, 8]]
   a.zip([1,2],[8])       #=&gt; [[4,1,8], [5,2,nil], [6,nil,nil]]
&lt;/pre&gt;</method>
    <method name='|'>&lt;p&gt;Set Union---Returns a new array by joining this array with other_array, removing duplicates.&lt;/p&gt;&lt;pre&gt;   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] | [ &quot;c&quot;, &quot;d&quot;, &quot;a&quot; ]
          #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
&lt;/pre&gt;</method>
  </methods>
</help>