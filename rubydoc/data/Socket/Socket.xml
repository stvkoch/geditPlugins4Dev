<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<help>
  <comment>&lt;p&gt;Class &lt;tt&gt;Socket&lt;/tt&gt; provides access to the underlying operating system socket implementations. It can be used to provide more operating system specific functionality than the protocol-specific socket classes but at the expense of greater complexity. In particular, the class handles addresses using +struct sockaddr+ structures packed into Ruby strings, which can be a joy to manipulate.&lt;/p&gt;&lt;h3&gt;Exception Handling&lt;/h3&gt;&lt;p&gt;Ruby&apos;s implementation of &lt;tt&gt;Socket&lt;/tt&gt; causes an exception to be raised based on the error generated by the system dependent implementation. This is why the methods are documented in a way that isolate Unix-based system exceptions from Windows based exceptions. If more information on particular exception is needed please refer to the Unix manual pages or the Windows WinSock reference.&lt;/p&gt;&lt;h3&gt;Documentation by&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Zach Dennis&lt;/li&gt;&lt;li&gt;Sam Roberts&lt;/li&gt;&lt;li&gt;&lt;em&gt;Programming Ruby&lt;/em&gt; from The Pragmatic Bookshelf.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Much material in this documentation is taken with permission from &lt;em&gt;Programming Ruby&lt;/em&gt; from The Pragmatic Bookshelf.&lt;/p&gt;</comment>
  <methods>
    <method name='getaddrinfo'>&lt;p&gt;Return address information for &lt;tt&gt;host&lt;/tt&gt; and &lt;tt&gt;port&lt;/tt&gt;. The remaining arguments are hints that limit the address information returned.&lt;/p&gt;&lt;p&gt;This method corresponds closely to the POSIX.1g getaddrinfo() definition.&lt;/p&gt;&lt;h3&gt;Parameters&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;tt&gt;host&lt;/tt&gt; is a host name or an address string (dotted decimal for IPv4, or a hex string for IPv6) for which to return information. A nil is also allowed, its meaning depends on &lt;tt&gt;flags&lt;/tt&gt;, see below.&lt;/li&gt;&lt;li&gt;&lt;tt&gt;service&lt;/tt&gt; is a service name (&quot;http&quot;, &quot;ssh&quot;, ...), or a port number (80, 22, ...), see Socket.getservbyname for more information. A nil is also allowed, meaning zero.&lt;/li&gt;&lt;li&gt;&lt;tt&gt;family&lt;/tt&gt; limits the output to a specific address family, one of the Socket::AF_* constants. Socket::AF_INET (IPv4) and Socket::AF_INET6 (IPv6) are the most commonly used families. You will usually pass either nil or Socket::AF_UNSPEC, allowing the IPv6 information to be returned first if &lt;tt&gt;host&lt;/tt&gt; is reachable via IPv6, and IPv4 information otherwise. The two strings &quot;AF_INET&quot; or &quot;AF_INET6&quot; are also allowed, they are converted to their respective Socket::AF_* constants.&lt;/li&gt;&lt;li&gt;&lt;tt&gt;socktype&lt;/tt&gt; limits the output to a specific type of socket, one of the Socket::SOCK_* constants. Socket::SOCK_STREAM (for TCP) and Socket::SOCK_DGRAM (for UDP) are the most commonly used socket types. If nil, then information for all types of sockets supported by &lt;tt&gt;service&lt;/tt&gt; will be returned. You will usually know what type of socket you intend to create, and should pass that socket type in.&lt;/li&gt;&lt;li&gt;&lt;tt&gt;protocol&lt;/tt&gt; limits the output to a specific protocol numpber, one of the Socket::IPPROTO_* constants. It is usually implied by the socket type (Socket::SOCK_STREAM =&gt; Socket::IPPROTO_TCP, ...), if you pass other than nil you already know what this is for.&lt;/li&gt;&lt;li&gt;&lt;tt&gt;flags&lt;/tt&gt; is one of the Socket::AI_* constants. They mean:&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Socket::AI_PASSIVE: when set, if &lt;tt&gt;host&lt;/tt&gt; is nil the &apos;any&apos; address will be returned, Socket::INADDR_ANY or 0 for IPv4, &quot;0::0&quot; or &quot;::&quot; for IPv6. This address is suitable for use by servers that will bind their socket and do a passive listen, thus the name of the flag. Otherwise the local or loopback address will be returned, this is &quot;127.0.0.1&quot; for IPv4 and &quot;::1&apos; for IPv6.&lt;/li&gt;&lt;li&gt;...&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3&gt;Returns&lt;/h3&gt;&lt;p&gt;Returns an array of arrays, where each subarray contains:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;address family, a string like &quot;AF_INET&quot; or &quot;AF_INET6&quot;&lt;/li&gt;&lt;li&gt;port number, the port number for &lt;tt&gt;service&lt;/tt&gt;&lt;/li&gt;&lt;li&gt;host name, either a canonical name for &lt;tt&gt;host&lt;/tt&gt;, or it&apos;s address in presentation format if the address could not be looked up.&lt;/li&gt;&lt;li&gt;host IP, the address of &lt;tt&gt;host&lt;/tt&gt; in presentation format&lt;/li&gt;&lt;li&gt;address family, as a numeric value (one of the Socket::AF_* constants).&lt;/li&gt;&lt;li&gt;socket type, as a numeric value (one of the Socket::SOCK_* constants).&lt;/li&gt;&lt;li&gt;protocol number, as a numeric value (one of the Socket::IPPROTO_* constants).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The first four values are identical to what is commonly returned as an address array, see IPSocket for more information.&lt;/p&gt;&lt;h3&gt;Examples&lt;/h3&gt;&lt;p&gt;Not all input combinations are valid, and while there are many combinations, only a few cases are common.&lt;/p&gt;&lt;p&gt;A typical client will call getaddrinfo with the &lt;tt&gt;host&lt;/tt&gt; and &lt;tt&gt;service&lt;/tt&gt; it wants to connect to. It knows that it will attempt to connect with either TCP or UDP, and specifies &lt;tt&gt;socktype&lt;/tt&gt; accordingly. It loops through all returned addresses, and try to connect to them in turn:&lt;/p&gt;&lt;pre&gt;  addrinfo = Socket::getaddrinfo(&apos;www.example.com&apos;, &apos;www&apos;, nil, Socket::SOCK_STREAM)
  addrinfo.each do |af, port, name, addr|
    begin
      sock = TCPSocket.new(addr, port)
      # ...
      exit 1
    rescue
    end
  end
&lt;/pre&gt;&lt;p&gt;With UDP you don&apos;t know if connect suceeded, but if communication fails, the next address can be tried.&lt;/p&gt;&lt;p&gt;A typical server will call getaddrinfo with a &lt;tt&gt;host&lt;/tt&gt; of nil, the &lt;tt&gt;service&lt;/tt&gt; it listens to, and a &lt;tt&gt;flags&lt;/tt&gt; of Socket::AI_PASSIVE. It will listen for connections on the first returned address:&lt;/p&gt;&lt;pre&gt;  addrinfo = Socket::getaddrinfo(nil, &apos;www&apos;, nil, Socket::SOCK_STREAM, nil, Socket::AI_PASSIVE)
  af, port, name, addr = addrinfo.first
  sock = TCPServer(addr, port)
  while( client = s.accept )
    # ...
  end
&lt;/pre&gt;</method>
    <method name='gethostbyname'>&lt;p&gt;Resolve &lt;tt&gt;host&lt;/tt&gt; and return name and address information for it, similarly to gethostbyname(3). &lt;tt&gt;host&lt;/tt&gt; can be a domain name or the presentation format of an address.&lt;/p&gt;&lt;p&gt;Returns an array of information similar to that found in a +struct hostent+:&lt;/p&gt;&lt;pre&gt;  - cannonical name: the cannonical name for host in the DNS, or a
    string representing the address
  - aliases: an array of aliases for the canonical name, there may be no aliases
  - address family: usually one of Socket::AF_INET or Socket::AF_INET6
  - address: a string, the binary value of the +struct sockaddr+ for this name, in
    the indicated address family
  - ...: if there are multiple addresses for this host,  a series of
    strings/+struct sockaddr+s may follow, not all necessarily in the same
    address family. Note that the fact that they may not be all in the same
    address family is a departure from the behaviour of gethostbyname(3).
&lt;/pre&gt;&lt;p&gt;Note: I believe that the fact that the multiple addresses returned are not necessarily in the same address family may be a bug, since if this function actually called gethostbyname(3), ALL the addresses returned in the trailing address list (h_addr_list from struct hostent) would be of the same address family! Examples from my system, OS X 10.3:&lt;/p&gt;&lt;pre&gt;  [&quot;localhost&quot;, [], 30, &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&quot;, &quot;\177\000\000\001&quot;]
    and
  [&quot;ensemble.local&quot;, [], 30, &quot;\376\200\000\004\000\000\000\000\002\003\223\377\376\255\010\214&quot;, &quot;\300\250{\232&quot; ]
&lt;/pre&gt;&lt;p&gt;Similar information can be returned by Socket.getaddrinfo if called as:&lt;/p&gt;&lt;pre&gt;   Socket.getaddrinfo(&lt;tt&gt;host&lt;/tt&gt;, 0, Socket::AF_UNSPEC, Socket::SOCK_STREAM, nil, Socket::AI_CANONNAME)
&lt;/pre&gt;&lt;h2&gt;Examples&lt;/h2&gt;&lt;pre&gt;  Socket.gethostbyname &quot;example.com&quot;
  =&gt; [&quot;example.com&quot;, [], 2, &quot;\300\000\&quot;\246&quot;]
&lt;/pre&gt;&lt;p&gt;This name has no DNS aliases, and a single IPv4 address.&lt;/p&gt;&lt;pre&gt;  Socket.gethostbyname &quot;smtp.telus.net&quot;
  =&gt; [&quot;smtp.svc.telus.net&quot;, [&quot;smtp.telus.net&quot;], 2, &quot;\307\271\334\371&quot;]
&lt;/pre&gt;&lt;p&gt;This name is an an alias so the canonical name is returned, as well as the alias and a single IPv4 address.&lt;/p&gt;&lt;pre&gt;  Socket.gethostbyname &quot;localhost&quot;
  =&gt; [&quot;localhost&quot;, [], 30, &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&quot;, &quot;\177\000\000\001&quot;]
&lt;/pre&gt;&lt;p&gt;This machine has no aliases, returns an IPv6 address, and has an additional IPv4 address.&lt;/p&gt;&lt;p&gt;&lt;tt&gt;host&lt;/tt&gt; can also be an IP address in presentation format, in which case a reverse lookup is done on the address:&lt;/p&gt;&lt;pre&gt;  Socket.gethostbyname(&quot;127.0.0.1&quot;)
  =&gt; [&quot;localhost&quot;, [], 2, &quot;\177\000\000\001&quot;]

  Socket.gethostbyname(&quot;192.0.34.166&quot;)
  =&gt; [&quot;www.example.com&quot;, [], 2, &quot;\300\000\&quot;\246&quot;]
&lt;/pre&gt;&lt;h2&gt;See&lt;/h2&gt;&lt;p&gt;See: Socket.getaddrinfo&lt;/p&gt;</method>
    <method name='getservbyname'>&lt;p&gt;&lt;tt&gt;name&lt;/tt&gt; is a service name (&quot;ftp&quot;, &quot;telnet&quot;, ...) and proto is a protocol name (&quot;udp&quot;, &quot;tcp&quot;, ...). &apos;/etc/services&apos; (or your system&apos;s equivalent) is searched for a service for &lt;tt&gt;name&lt;/tt&gt; and &lt;tt&gt;proto&lt;/tt&gt;, and the port number is returned.&lt;/p&gt;&lt;p&gt;Note that unlike Socket.getaddrinfo, &lt;tt&gt;proto&lt;/tt&gt; may not be specified using the Socket::SOCK_* constants, a string must must be used.&lt;/p&gt;</method>
    <method name='accept'>&lt;p&gt;Accepts an incoming connection returning an array containing a new Socket object and a string holding the &lt;tt&gt;struct&lt;/tt&gt; sockaddr information about the caller.&lt;/p&gt;&lt;h3&gt;Example&lt;/h3&gt;&lt;pre&gt;     # In one script, start this first
     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client, client_sockaddr = socket.accept
     puts &quot;The client said, &apos;#{socket.readline.chomp}&apos;&quot;
     client.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )
     socket.connect( sockaddr )
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, &apos;#{socket.readline.chomp}&apos;&quot;
     socket.close
&lt;/pre&gt;&lt;h3&gt;Unix-based Exceptions&lt;/h3&gt;&lt;p&gt;On unix-based based systems the following system exceptions may be raised if the call to &lt;em&gt;accept&lt;/em&gt; fails:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Errno::EAGAIN - O_NONBLOCK is set for the &lt;tt&gt;socket&lt;/tt&gt; file descriptor and no connections are parent to be accepted&lt;/li&gt;&lt;li&gt;Errno::EWOULDBLOCK - same as Errno::EAGAIN&lt;/li&gt;&lt;li&gt;Errno::EBADF - the &lt;tt&gt;socket&lt;/tt&gt; is not a valid file descriptor&lt;/li&gt;&lt;li&gt;Errno::ECONNABORTED - a connection has been aborted&lt;/li&gt;&lt;li&gt;Errno::EFAULT - the socket&apos;s internal address or address length parameter cannot be access or written&lt;/li&gt;&lt;li&gt;Errno::EINTR - the &lt;em&gt;accept&lt;/em&gt; method was interrupted by a signal that was caught before a valid connection arrived&lt;/li&gt;&lt;li&gt;Errno::EINVAL - the &lt;tt&gt;socket&lt;/tt&gt; is not accepting connections&lt;/li&gt;&lt;li&gt;Errno::EMFILE - OPEN_MAX file descriptors are currently open in the calling process&lt;/li&gt;&lt;li&gt;Errno::ENOBUFS - no buffer space is available&lt;/li&gt;&lt;li&gt;Errno::ENOMEM - there was insufficient memory available to complete the operation&lt;/li&gt;&lt;li&gt;Errno::ENOSR - there was insufficient STREAMS resources available to complete the operation&lt;/li&gt;&lt;li&gt;Errno::ENFILE - the maximum number of file descriptors in the system are already open&lt;/li&gt;&lt;li&gt;Errno::ENOTSOCK - the &lt;tt&gt;socket&lt;/tt&gt; does not refer to a socket&lt;/li&gt;&lt;li&gt;Errno::EOPNOTSUPP - the socket type for the calling &lt;tt&gt;socket&lt;/tt&gt; does not support accept connections&lt;/li&gt;&lt;li&gt;Errno::EPROTO - a protocol error has occurred&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Windows Exceptions&lt;/h3&gt;&lt;p&gt;On Windows systems the following system exceptions may be raised if the call to &lt;em&gt;accept&lt;/em&gt; fails:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Errno::ECONNRESET - an incoming connection was indicated, but was terminated by the remote peer prior to accepting the connection&lt;/li&gt;&lt;li&gt;Errno::EFAULT - the socket&apos;s internal address or address length parameter is too small or is not a valid part of the user space address&lt;/li&gt;&lt;li&gt;Errno::EINVAL - the &lt;em&gt;listen&lt;/em&gt; method was not invoked prior to calling &lt;em&gt;accept&lt;/em&gt;&lt;/li&gt;&lt;li&gt;Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or the service provider is still processing a callback function&lt;/li&gt;&lt;li&gt;Errno::EMFILE - the queue is not empty, upong etry to &lt;em&gt;accept&lt;/em&gt; and there are no socket descriptors available&lt;/li&gt;&lt;li&gt;Errno::ENETDOWN - the network is down&lt;/li&gt;&lt;li&gt;Errno::ENOBUFS - no buffer space is available&lt;/li&gt;&lt;li&gt;Errno::ENOTSOCK - &lt;tt&gt;socket&lt;/tt&gt; is not a socket&lt;/li&gt;&lt;li&gt;Errno::EOPNOTSUPP - &lt;tt&gt;socket&lt;/tt&gt; is not a type that supports connection-oriented service.&lt;/li&gt;&lt;li&gt;Errno::EWOULDBLOCK - &lt;tt&gt;socket&lt;/tt&gt; is marked as nonblocking and no connections are present to be accepted&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;See&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;accept manual pages on unix-based systems&lt;/li&gt;&lt;li&gt;accept function in Microsoft&apos;s Winsock functions reference&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='accept_nonblock'>&lt;p&gt;Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the underlying file descriptor. It returns an array containg the accpeted socket for the incoming connection, &lt;em&gt;client_socket&lt;/em&gt;, and a string that contains the &lt;tt&gt;struct&lt;/tt&gt; sockaddr information about the caller, &lt;em&gt;client_sockaddr&lt;/em&gt;.&lt;/p&gt;&lt;h3&gt;Example&lt;/h3&gt;&lt;pre&gt;     # In one script, start this first
     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, &apos;localhost&apos;)
     socket.bind(sockaddr)
     socket.listen(5)
     begin
       client_socket, client_sockaddr = socket.accept_nonblock
     rescue Errno::EAGAIN, Errno::ECONNABORTED, Errno::EPROTO, Errno::EINTR
       IO.select([socket])
       retry
     end
     puts &quot;The client said, &apos;#{socket.readline.chomp}&apos;&quot;
     client_socket.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, &apos;localhost&apos;)
     socket.connect(sockaddr)
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, &apos;#{socket.readline.chomp}&apos;&quot;
     socket.close
&lt;/pre&gt;&lt;p&gt;Refer to Socket#accept for the exceptions that may be thrown if the call to &lt;em&gt;accept_nonblock&lt;/em&gt; fails.&lt;/p&gt;&lt;p&gt;Socket#accept_nonblock may raise any error corresponding to accept(2) failure, including Errno::EAGAIN.&lt;/p&gt;&lt;h3&gt;See&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Socket#accept&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='bind'>&lt;p&gt;Binds to the given &lt;tt&gt;struct&lt;/tt&gt; sockaddr.&lt;/p&gt;&lt;h3&gt;Parameter&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;tt&gt;server_sockaddr&lt;/tt&gt; - the &lt;tt&gt;struct&lt;/tt&gt; sockaddr contained in a string&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Example&lt;/h3&gt;&lt;pre&gt;     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )
     socket.bind( sockaddr )
&lt;/pre&gt;&lt;h3&gt;Unix-based Exceptions&lt;/h3&gt;&lt;p&gt;On unix-based based systems the following system exceptions may be raised if the call to &lt;em&gt;bind&lt;/em&gt; fails:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Errno::EACCES - the specified &lt;em&gt;sockaddr&lt;/em&gt; is protected and the current user does not have permission to bind to it&lt;/li&gt;&lt;li&gt;Errno::EADDRINUSE - the specified &lt;em&gt;sockaddr&lt;/em&gt; is already in use&lt;/li&gt;&lt;li&gt;Errno::EADDRNOTAVAIL - the specified &lt;em&gt;sockaddr&lt;/em&gt; is not available from the local machine&lt;/li&gt;&lt;li&gt;Errno::EAFNOSUPPORT - the specified &lt;em&gt;sockaddr&lt;/em&gt; isnot a valid address for the family of the calling &lt;tt&gt;socket&lt;/tt&gt;&lt;/li&gt;&lt;li&gt;Errno::EBADF - the &lt;em&gt;sockaddr&lt;/em&gt; specified is not a valid file descriptor&lt;/li&gt;&lt;li&gt;Errno::EFAULT - the &lt;em&gt;sockaddr&lt;/em&gt; argument cannot be accessed&lt;/li&gt;&lt;li&gt;Errno::EINVAL - the &lt;tt&gt;socket&lt;/tt&gt; is already bound to an address, and the protocol does not support binding to the new &lt;em&gt;sockaddr&lt;/em&gt; or the &lt;tt&gt;socket&lt;/tt&gt; has been shut down.&lt;/li&gt;&lt;li&gt;Errno::EINVAL - the address length is not a valid length for the address family&lt;/li&gt;&lt;li&gt;Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded PATH_MAX&lt;/li&gt;&lt;li&gt;Errno::ENOBUFS - no buffer space is available&lt;/li&gt;&lt;li&gt;Errno::ENOSR - there were insufficient STREAMS resources available to complete the operation&lt;/li&gt;&lt;li&gt;Errno::ENOTSOCK - the &lt;tt&gt;socket&lt;/tt&gt; does not refer to a socket&lt;/li&gt;&lt;li&gt;Errno::EOPNOTSUPP - the socket type of the &lt;tt&gt;socket&lt;/tt&gt; does not support binding to an address&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;On unix-based based systems if the address family of the calling &lt;tt&gt;socket&lt;/tt&gt; is Socket::AF_UNIX the follow exceptions may be raised if the call to &lt;em&gt;bind&lt;/em&gt; fails:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Errno::EACCES - search permission is denied for a component of the prefix path or write access to the &lt;tt&gt;socket&lt;/tt&gt; is denided&lt;/li&gt;&lt;li&gt;Errno::EDESTADDRREQ - the &lt;em&gt;sockaddr&lt;/em&gt; argument is a null pointer&lt;/li&gt;&lt;li&gt;Errno::EISDIR - same as Errno::EDESTADDRREQ&lt;/li&gt;&lt;li&gt;Errno::EIO - an i/o error occurred&lt;/li&gt;&lt;li&gt;Errno::ELOOP - too many symbolic links were encountered in translating the pathname in &lt;em&gt;sockaddr&lt;/em&gt;&lt;/li&gt;&lt;li&gt;Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX characters, or an entired pathname exceeded PATH_MAX characters&lt;/li&gt;&lt;li&gt;Errno::ENOENT - a component of the pathname does not name an existing file or the pathname is an empty string&lt;/li&gt;&lt;li&gt;Errno::ENOTDIR - a component of the path prefix of the pathname in &lt;em&gt;sockaddr&lt;/em&gt; is not a directory&lt;/li&gt;&lt;li&gt;Errno::EROFS - the name would reside on a read only filesystem&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Windows Exceptions&lt;/h3&gt;&lt;p&gt;On Windows systems the following system exceptions may be raised if the call to &lt;em&gt;bind&lt;/em&gt; fails:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Errno::ENETDOWN-- the network is down&lt;/li&gt;&lt;li&gt;Errno::EACCES - the attempt to connect the datagram socket to the broadcast address failed&lt;/li&gt;&lt;li&gt;Errno::EADDRINUSE - the socket&apos;s local address is already in use&lt;/li&gt;&lt;li&gt;Errno::EADDRNOTAVAIL - the specified address is not a valid address for this computer&lt;/li&gt;&lt;li&gt;Errno::EFAULT - the socket&apos;s internal address or address length parameter is too small or is not a valid part of the user space addressed&lt;/li&gt;&lt;li&gt;Errno::EINVAL - the &lt;tt&gt;socket&lt;/tt&gt; is already bound to an address&lt;/li&gt;&lt;li&gt;Errno::ENOBUFS - no buffer space is available&lt;/li&gt;&lt;li&gt;Errno::ENOTSOCK - the &lt;tt&gt;socket&lt;/tt&gt; argument does not refer to a socket&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;See&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;bind manual pages on unix-based systems&lt;/li&gt;&lt;li&gt;bind function in Microsoft&apos;s Winsock functions reference&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='connect'>&lt;p&gt;Requests a connection to be made on the given &lt;tt&gt;server_sockaddr&lt;/tt&gt;. Returns 0 if successful, otherwise an exception is raised.&lt;/p&gt;&lt;h3&gt;Parameter&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;tt&gt;server_sockaddr&lt;/tt&gt; - the &lt;tt&gt;struct&lt;/tt&gt; sockaddr contained in a string&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Example:&lt;/h3&gt;&lt;pre&gt;     # Pull down Google&apos;s web page
     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 80, &apos;www.google.com&apos; )
     socket.connect( sockaddr )
     socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )
     results = socket.read
&lt;/pre&gt;&lt;h3&gt;Unix-based Exceptions&lt;/h3&gt;&lt;p&gt;On unix-based systems the following system exceptions may be raised if the call to &lt;em&gt;connect&lt;/em&gt; fails:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Errno::EACCES - search permission is denied for a component of the prefix path or write access to the &lt;tt&gt;socket&lt;/tt&gt; is denided&lt;/li&gt;&lt;li&gt;Errno::EADDRINUSE - the &lt;em&gt;sockaddr&lt;/em&gt; is already in use&lt;/li&gt;&lt;li&gt;Errno::EADDRNOTAVAIL - the specified &lt;em&gt;sockaddr&lt;/em&gt; is not available from the local machine&lt;/li&gt;&lt;li&gt;Errno::EAFNOSUPPORT - the specified &lt;em&gt;sockaddr&lt;/em&gt; is not a valid address for the address family of the specified &lt;tt&gt;socket&lt;/tt&gt;&lt;/li&gt;&lt;li&gt;Errno::EALREADY - a connection is already in progress for the specified socket&lt;/li&gt;&lt;li&gt;Errno::EBADF - the &lt;tt&gt;socket&lt;/tt&gt; is not a valid file descriptor&lt;/li&gt;&lt;li&gt;Errno::ECONNREFUSED - the target &lt;em&gt;sockaddr&lt;/em&gt; was not listening for connections refused the connection request&lt;/li&gt;&lt;li&gt;Errno::ECONNRESET - the remote host reset the connection request&lt;/li&gt;&lt;li&gt;Errno::EFAULT - the &lt;em&gt;sockaddr&lt;/em&gt; cannot be accessed&lt;/li&gt;&lt;li&gt;Errno::EHOSTUNREACH - the destination host cannot be reached (probably because the host is down or a remote router cannot reach it)&lt;/li&gt;&lt;li&gt;Errno::EINPROGRESS - the O_NONBLOCK is set for the &lt;tt&gt;socket&lt;/tt&gt; and the connection cnanot be immediately established; the connection will be established asynchronously&lt;/li&gt;&lt;li&gt;Errno::EINTR - the attempt to establish the connection was interrupted by delivery of a signal that was caught; the connection will be established asynchronously&lt;/li&gt;&lt;li&gt;Errno::EISCONN - the specified &lt;tt&gt;socket&lt;/tt&gt; is already connected&lt;/li&gt;&lt;li&gt;Errno::EINVAL - the address length used for the &lt;em&gt;sockaddr&lt;/em&gt; is not a valid length for the address family or there is an invalid family in &lt;em&gt;sockaddr&lt;/em&gt;&lt;/li&gt;&lt;li&gt;Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded PATH_MAX&lt;/li&gt;&lt;li&gt;Errno::ENETDOWN - the local interface used to reach the destination is down&lt;/li&gt;&lt;li&gt;Errno::ENETUNREACH - no route to the network is present&lt;/li&gt;&lt;li&gt;Errno::ENOBUFS - no buffer space is available&lt;/li&gt;&lt;li&gt;Errno::ENOSR - there were insufficient STREAMS resources available to complete the operation&lt;/li&gt;&lt;li&gt;Errno::ENOTSOCK - the &lt;tt&gt;socket&lt;/tt&gt; argument does not refer to a socket&lt;/li&gt;&lt;li&gt;Errno::EOPNOTSUPP - the calling &lt;tt&gt;socket&lt;/tt&gt; is listening and cannot be connected&lt;/li&gt;&lt;li&gt;Errno::EPROTOTYPE - the &lt;em&gt;sockaddr&lt;/em&gt; has a different type than the socket bound to the specified peer address&lt;/li&gt;&lt;li&gt;Errno::ETIMEDOUT - the attempt to connect time out before a connection was made.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;On unix-based systems if the address family of the calling &lt;tt&gt;socket&lt;/tt&gt; is AF_UNIX the follow exceptions may be raised if the call to &lt;em&gt;connect&lt;/em&gt; fails:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Errno::EIO - an i/o error occured while reading from or writing to the file system&lt;/li&gt;&lt;li&gt;Errno::ELOOP - too many symbolic links were encountered in translating the pathname in &lt;em&gt;sockaddr&lt;/em&gt;&lt;/li&gt;&lt;li&gt;Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX characters, or an entired pathname exceeded PATH_MAX characters&lt;/li&gt;&lt;li&gt;Errno::ENOENT - a component of the pathname does not name an existing file or the pathname is an empty string&lt;/li&gt;&lt;li&gt;Errno::ENOTDIR - a component of the path prefix of the pathname in &lt;em&gt;sockaddr&lt;/em&gt; is not a directory&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Windows Exceptions&lt;/h3&gt;&lt;p&gt;On Windows systems the following system exceptions may be raised if the call to &lt;em&gt;connect&lt;/em&gt; fails:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Errno::ENETDOWN - the network is down&lt;/li&gt;&lt;li&gt;Errno::EADDRINUSE - the socket&apos;s local address is already in use&lt;/li&gt;&lt;li&gt;Errno::EINTR - the socket was cancelled&lt;/li&gt;&lt;li&gt;Errno::EINPROGRESS - a blocking socket is in progress or the service provider is still processing a callback function. Or a nonblocking connect call is in progress on the &lt;tt&gt;socket&lt;/tt&gt;.&lt;/li&gt;&lt;li&gt;Errno::EALREADY - see Errno::EINVAL&lt;/li&gt;&lt;li&gt;Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as ADDR_ANY TODO check ADDRANY TO INADDR_ANY&lt;/li&gt;&lt;li&gt;Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with with this &lt;tt&gt;socket&lt;/tt&gt;&lt;/li&gt;&lt;li&gt;Errno::ECONNREFUSED - the target &lt;em&gt;sockaddr&lt;/em&gt; was not listening for connections refused the connection request&lt;/li&gt;&lt;li&gt;Errno::EFAULT - the socket&apos;s internal address or address length parameter is too small or is not a valid part of the user space address&lt;/li&gt;&lt;li&gt;Errno::EINVAL - the &lt;tt&gt;socket&lt;/tt&gt; is a listening socket&lt;/li&gt;&lt;li&gt;Errno::EISCONN - the &lt;tt&gt;socket&lt;/tt&gt; is already connected&lt;/li&gt;&lt;li&gt;Errno::ENETUNREACH - the network cannot be reached from this host at this time&lt;/li&gt;&lt;li&gt;Errno::EHOSTUNREACH - no route to the network is present&lt;/li&gt;&lt;li&gt;Errno::ENOBUFS - no buffer space is available&lt;/li&gt;&lt;li&gt;Errno::ENOTSOCK - the &lt;tt&gt;socket&lt;/tt&gt; argument does not refer to a socket&lt;/li&gt;&lt;li&gt;Errno::ETIMEDOUT - the attempt to connect time out before a connection was made.&lt;/li&gt;&lt;li&gt;Errno::EWOULDBLOCK - the socket is marked as nonblocking and the connection cannot be completed immediately&lt;/li&gt;&lt;li&gt;Errno::EACCES - the attempt to connect the datagram socket to the broadcast address failed&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;See&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;connect manual pages on unix-based systems&lt;/li&gt;&lt;li&gt;connect function in Microsoft&apos;s Winsock functions reference&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='connect_nonblock'>&lt;p&gt;Requests a connection to be made on the given &lt;tt&gt;server_sockaddr&lt;/tt&gt; after O_NONBLOCK is set for the underlying file descriptor. Returns 0 if successful, otherwise an exception is raised.&lt;/p&gt;&lt;h3&gt;Parameter&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;tt&gt;server_sockaddr&lt;/tt&gt; - the &lt;tt&gt;struct&lt;/tt&gt; sockaddr contained in a string&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Example:&lt;/h3&gt;&lt;pre&gt;     # Pull down Google&apos;s web page
     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(80, &apos;www.google.com&apos;)
     begin
       socket.connect_nonblock(sockaddr)
     rescue Errno::EINPROGRESS
       IO.select(nil, [socket])
       begin
         socket.connect_nonblock(sockaddr)
       rescue Errno::EISCONN
       end
     end
     socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;)
     results = socket.read
&lt;/pre&gt;&lt;p&gt;Refer to Socket#connect for the exceptions that may be thrown if the call to &lt;em&gt;connect_nonblock&lt;/em&gt; fails.&lt;/p&gt;&lt;p&gt;Socket#connect_nonblock may raise any error corresponding to connect(2) failure, including Errno::EINPROGRESS.&lt;/p&gt;&lt;h3&gt;See&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Socket#connect&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='listen'>&lt;p&gt;Listens for connections, using the specified &lt;tt&gt;int&lt;/tt&gt; as the backlog. A call to &lt;em&gt;listen&lt;/em&gt; only applies if the &lt;tt&gt;socket&lt;/tt&gt; is of type SOCK_STREAM or SOCK_SEQPACKET.&lt;/p&gt;&lt;h3&gt;Parameter&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;tt&gt;backlog&lt;/tt&gt; - the maximum length of the queue for pending connections.&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Example 1&lt;/h3&gt;&lt;pre&gt;     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )
     socket.bind( sockaddr )
     socket.listen( 5 )
&lt;/pre&gt;&lt;h3&gt;Example 2 (listening on an arbitary port, unix-based systems only):&lt;/h3&gt;&lt;pre&gt;     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     socket.listen( 1 )
&lt;/pre&gt;&lt;h3&gt;Unix-based Exceptions&lt;/h3&gt;&lt;p&gt;On unix based systems the above will work because a new &lt;tt&gt;sockaddr&lt;/tt&gt; struct is created on the address ADDR_ANY, for an arbitrary port number as handed off by the kernel. It will not work on Windows, because Windows requires that the &lt;tt&gt;socket&lt;/tt&gt; is bound by calling &lt;em&gt;bind&lt;/em&gt; before it can &lt;em&gt;listen&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;If the &lt;em&gt;backlog&lt;/em&gt; amount exceeds the implementation-dependent maximum queue length, the implementation&apos;s maximum queue length will be used.&lt;/p&gt;&lt;p&gt;On unix-based based systems the following system exceptions may be raised if the call to &lt;em&gt;listen&lt;/em&gt; fails:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Errno::EBADF - the &lt;em&gt;socket&lt;/em&gt; argument is not a valid file descriptor&lt;/li&gt;&lt;li&gt;Errno::EDESTADDRREQ - the &lt;em&gt;socket&lt;/em&gt; is not bound to a local address, and the protocol does not support listening on an unbound socket&lt;/li&gt;&lt;li&gt;Errno::EINVAL - the &lt;em&gt;socket&lt;/em&gt; is already connected&lt;/li&gt;&lt;li&gt;Errno::ENOTSOCK - the &lt;em&gt;socket&lt;/em&gt; argument does not refer to a socket&lt;/li&gt;&lt;li&gt;Errno::EOPNOTSUPP - the &lt;em&gt;socket&lt;/em&gt; protocol does not support listen&lt;/li&gt;&lt;li&gt;Errno::EACCES - the calling process does not have approriate privileges&lt;/li&gt;&lt;li&gt;Errno::EINVAL - the &lt;em&gt;socket&lt;/em&gt; has been shut down&lt;/li&gt;&lt;li&gt;Errno::ENOBUFS - insufficient resources are available in the system to complete the call&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Windows Exceptions&lt;/h3&gt;&lt;p&gt;On Windows systems the following system exceptions may be raised if the call to &lt;em&gt;listen&lt;/em&gt; fails:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Errno::ENETDOWN - the network is down&lt;/li&gt;&lt;li&gt;Errno::EADDRINUSE - the socket&apos;s local address is already in use. This usually occurs during the execution of &lt;em&gt;bind&lt;/em&gt; but could be delayed if the call to &lt;em&gt;bind&lt;/em&gt; was to a partially wildcard address (involving ADDR_ANY) and if a specific address needs to be commmitted at the time of the call to &lt;em&gt;listen&lt;/em&gt;&lt;/li&gt;&lt;li&gt;Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the service provider is still processing a callback function&lt;/li&gt;&lt;li&gt;Errno::EINVAL - the &lt;tt&gt;socket&lt;/tt&gt; has not been bound with a call to &lt;em&gt;bind&lt;/em&gt;.&lt;/li&gt;&lt;li&gt;Errno::EISCONN - the &lt;tt&gt;socket&lt;/tt&gt; is already connected&lt;/li&gt;&lt;li&gt;Errno::EMFILE - no more socket descriptors are available&lt;/li&gt;&lt;li&gt;Errno::ENOBUFS - no buffer space is available&lt;/li&gt;&lt;li&gt;Errno::ENOTSOC - &lt;tt&gt;socket&lt;/tt&gt; is not a socket&lt;/li&gt;&lt;li&gt;Errno::EOPNOTSUPP - the referenced &lt;tt&gt;socket&lt;/tt&gt; is not a type that supports the &lt;em&gt;listen&lt;/em&gt; method&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;See&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;listen manual pages on unix-based systems&lt;/li&gt;&lt;li&gt;listen function in Microsoft&apos;s Winsock functions reference&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='recvfrom'>&lt;p&gt;Receives up to &lt;em&gt;maxlen&lt;/em&gt; bytes from &lt;tt&gt;socket&lt;/tt&gt;. &lt;em&gt;flags&lt;/em&gt; is zero or more of the &lt;tt&gt;MSG_&lt;/tt&gt; options. The first element of the results, &lt;em&gt;mesg&lt;/em&gt;, is the data received. The second element, &lt;em&gt;sender_sockaddr&lt;/em&gt;, contains protocol-specific information on the sender.&lt;/p&gt;&lt;h3&gt;Parameters&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;tt&gt;maxlen&lt;/tt&gt; - the number of bytes to receive from the socket&lt;/li&gt;&lt;li&gt;&lt;tt&gt;flags&lt;/tt&gt; - zero or more of the &lt;tt&gt;MSG_&lt;/tt&gt; options&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Example&lt;/h3&gt;&lt;pre&gt;     # In one file, start this first
     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client, client_sockaddr = socket.accept
     data = client.recvfrom( 20 )[0].chomp
     puts &quot;I only received 20 bytes &apos;#{data}&apos;&quot;
     sleep 1
     socket.close

     # In another file, start this second
     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )
     socket.connect( sockaddr )
     socket.puts &quot;Watch this get cut short!&quot;
     socket.close
&lt;/pre&gt;&lt;h3&gt;Unix-based Exceptions&lt;/h3&gt;&lt;p&gt;On unix-based based systems the following system exceptions may be raised if the call to &lt;em&gt;recvfrom&lt;/em&gt; fails:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Errno::EAGAIN - the &lt;tt&gt;socket&lt;/tt&gt; file descriptor is marked as O_NONBLOCK and no data is waiting to be received; or MSG_OOB is set and no out-of-band data is available and either the &lt;tt&gt;socket&lt;/tt&gt; file descriptor is marked as O_NONBLOCK or the &lt;tt&gt;socket&lt;/tt&gt; does not support blocking to wait for out-of-band-data&lt;/li&gt;&lt;li&gt;Errno::EWOULDBLOCK - see Errno::EAGAIN&lt;/li&gt;&lt;li&gt;Errno::EBADF - the &lt;tt&gt;socket&lt;/tt&gt; is not a valid file descriptor&lt;/li&gt;&lt;li&gt;Errno::ECONNRESET - a connection was forcibly closed by a peer&lt;/li&gt;&lt;li&gt;Errno::EFAULT - the socket&apos;s internal buffer, address or address length cannot be accessed or written&lt;/li&gt;&lt;li&gt;Errno::EINTR - a signal interupted &lt;em&gt;recvfrom&lt;/em&gt; before any data was available&lt;/li&gt;&lt;li&gt;Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is available&lt;/li&gt;&lt;li&gt;Errno::EIO - an i/o error occurred while reading from or writing to the filesystem&lt;/li&gt;&lt;li&gt;Errno::ENOBUFS - insufficient resources were available in the system to perform the operation&lt;/li&gt;&lt;li&gt;Errno::ENOMEM - insufficient memory was available to fulfill the request&lt;/li&gt;&lt;li&gt;Errno::ENOSR - there were insufficient STREAMS resources available to complete the operation&lt;/li&gt;&lt;li&gt;Errno::ENOTCONN - a receive is attempted on a connection-mode socket that is not connected&lt;/li&gt;&lt;li&gt;Errno::ENOTSOCK - the &lt;tt&gt;socket&lt;/tt&gt; does not refer to a socket&lt;/li&gt;&lt;li&gt;Errno::EOPNOTSUPP - the specified flags are not supported for this socket type&lt;/li&gt;&lt;li&gt;Errno::ETIMEDOUT - the connection timed out during connection establishment or due to a transmission timeout on an active connection&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Windows Exceptions&lt;/h3&gt;&lt;p&gt;On Windows systems the following system exceptions may be raised if the call to &lt;em&gt;recvfrom&lt;/em&gt; fails:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Errno::ENETDOWN - the network is down&lt;/li&gt;&lt;li&gt;Errno::EFAULT - the internal buffer and from parameters on &lt;tt&gt;socket&lt;/tt&gt; are not part of the user address space, or the internal fromlen parameter is too small to accomodate the peer address&lt;/li&gt;&lt;li&gt;Errno::EINTR - the (blocking) call was cancelled by an internal call to the WinSock function WSACancelBlockingCall&lt;/li&gt;&lt;li&gt;Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or the service provider is still processing a callback function&lt;/li&gt;&lt;li&gt;Errno::EINVAL - &lt;tt&gt;socket&lt;/tt&gt; has not been bound with a call to &lt;em&gt;bind&lt;/em&gt;, or an unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal len parameter on &lt;tt&gt;socket&lt;/tt&gt; was zero or negative&lt;/li&gt;&lt;li&gt;Errno::EISCONN - &lt;tt&gt;socket&lt;/tt&gt; is already connected. The call to &lt;em&gt;recvfrom&lt;/em&gt; is not permitted with a connected socket on a socket that is connetion oriented or connectionless.&lt;/li&gt;&lt;li&gt;Errno::ENETRESET - the connection has been broken due to the keep-alive activity detecting a failure while the operation was in progress.&lt;/li&gt;&lt;li&gt;Errno::EOPNOTSUPP - MSG_OOB was specified, but &lt;tt&gt;socket&lt;/tt&gt; is not stream-style such as type SOCK_STREAM. OOB data is not supported in the communication domain associated with &lt;tt&gt;socket&lt;/tt&gt;, or &lt;tt&gt;socket&lt;/tt&gt; is unidirectional and supports only send operations&lt;/li&gt;&lt;li&gt;Errno::ESHUTDOWN - &lt;tt&gt;socket&lt;/tt&gt; has been shutdown. It is not possible to call &lt;em&gt;recvfrom&lt;/em&gt; on a socket after &lt;em&gt;shutdown&lt;/em&gt; has been invoked.&lt;/li&gt;&lt;li&gt;Errno::EWOULDBLOCK - &lt;tt&gt;socket&lt;/tt&gt; is marked as nonblocking and a call to &lt;em&gt;recvfrom&lt;/em&gt; would block.&lt;/li&gt;&lt;li&gt;Errno::EMSGSIZE - the message was too large to fit into the specified buffer and was truncated.&lt;/li&gt;&lt;li&gt;Errno::ETIMEDOUT - the connection has been dropped, because of a network failure or because the system on the other end went down without notice&lt;/li&gt;&lt;li&gt;Errno::ECONNRESET - the virtual circuit was reset by the remote side executing a hard or abortive close. The application should close the socket; it is no longer usable. On a UDP-datagram socket this error indicates a previous send operation resulted in an ICMP Port Unreachable message.&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='recvfrom_nonblock'>&lt;p&gt;Receives up to &lt;em&gt;maxlen&lt;/em&gt; bytes from &lt;tt&gt;socket&lt;/tt&gt; using recvfrom(2) after O_NONBLOCK is set for the underlying file descriptor. &lt;em&gt;flags&lt;/em&gt; is zero or more of the &lt;tt&gt;MSG_&lt;/tt&gt; options. The first element of the results, &lt;em&gt;mesg&lt;/em&gt;, is the data received. The second element, &lt;em&gt;sender_sockaddr&lt;/em&gt;, contains protocol-specific information on the sender.&lt;/p&gt;&lt;p&gt;When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns an empty string as data. The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.&lt;/p&gt;&lt;h3&gt;Parameters&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;tt&gt;maxlen&lt;/tt&gt; - the number of bytes to receive from the socket&lt;/li&gt;&lt;li&gt;&lt;tt&gt;flags&lt;/tt&gt; - zero or more of the &lt;tt&gt;MSG_&lt;/tt&gt; options&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Example&lt;/h3&gt;&lt;pre&gt;     # In one file, start this first
     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, &apos;localhost&apos;)
     socket.bind(sockaddr)
     socket.listen(5)
     client, client_sockaddr = socket.accept
     begin
       pair = client.recvfrom_nonblock(20)
     rescue Errno::EAGAIN
       IO.select([client])
       retry
     end
     data = pair[0].chomp
     puts &quot;I only received 20 bytes &apos;#{data}&apos;&quot;
     sleep 1
     socket.close

     # In another file, start this second
     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, &apos;localhost&apos;)
     socket.connect(sockaddr)
     socket.puts &quot;Watch this get cut short!&quot;
     socket.close
&lt;/pre&gt;&lt;p&gt;Refer to Socket#recvfrom for the exceptions that may be thrown if the call to &lt;em&gt;recvfrom_nonblock&lt;/em&gt; fails.&lt;/p&gt;&lt;p&gt;Socket#recvfrom_nonblock may raise any error corresponding to recvfrom(2) failure, including Errno::EAGAIN.&lt;/p&gt;&lt;h3&gt;See&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Socket#recvfrom&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='sysaccept'>&lt;p&gt;Accepts an incoming connection returnings an array containg the (integer) file descriptor for the incoming connection, &lt;em&gt;client_socket_fd&lt;/em&gt;, and a string that contains the &lt;tt&gt;struct&lt;/tt&gt; sockaddr information about the caller, &lt;em&gt;client_sockaddr&lt;/em&gt;.&lt;/p&gt;&lt;h3&gt;Example&lt;/h3&gt;&lt;pre&gt;     # In one script, start this first
     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client_fd, client_sockaddr = socket.sysaccept
     puts &quot;The client said, &apos;#{socket.readline.chomp}&apos;&quot;
     client_socket = Socket.for_fd( client_fd )
     client_socket.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require &apos;socket&apos;
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )
     socket.connect( sockaddr )
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, &apos;#{socket.readline.chomp}&apos;&quot;
     socket.close
&lt;/pre&gt;&lt;p&gt;Refer to Socket#accept for the exceptions that may be thrown if the call to &lt;em&gt;sysaccept&lt;/em&gt; fails.&lt;/p&gt;&lt;h3&gt;See&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Socket#accept&lt;/li&gt;&lt;/ul&gt;</method>
  </methods>
</help>