<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<help>
  <comment>&lt;p&gt;BigDecimal provides arbitrary-precision floating point decimal arithmetic.&lt;/p&gt;&lt;p&gt;Copyright (C) 2002 by Shigeo Kobayashi &lt;shigeo@tinyforest.gr.jp&gt;. You may distribute under the terms of either the GNU General Public License or the Artistic License, as specified in the README file of the BigDecimal distribution.&lt;/p&gt;&lt;p&gt;Documented by mathew &lt;meta@pobox.com&gt;.&lt;/p&gt;&lt;h1&gt;Introduction&lt;/h1&gt;&lt;p&gt;Ruby provides built-in support for arbitrary precision integer arithmetic. For example:&lt;/p&gt;&lt;p&gt;42**13 -&gt; 1265437718438866624512&lt;/p&gt;&lt;p&gt;BigDecimal provides similar support for very large or very accurate floating point numbers.&lt;/p&gt;&lt;p&gt;Decimal arithmetic is also useful for general calculation, because it provides the correct answers people expect--whereas normal binary floating point arithmetic often introduces subtle errors because of the conversion between base 10 and base 2. For example, try:&lt;/p&gt;&lt;pre&gt;  sum = 0
  for i in (1..10000)
    sum = sum + 0.0001
  end
  print sum
&lt;/pre&gt;&lt;p&gt;and contrast with the output from:&lt;/p&gt;&lt;pre&gt;  require &apos;bigdecimal&apos;

  sum = BigDecimal.new(&quot;0&quot;)
  for i in (1..10000)
    sum = sum + BigDecimal.new(&quot;0.0001&quot;)
  end
  print sum
&lt;/pre&gt;&lt;p&gt;Similarly:&lt;/p&gt;&lt;p&gt;(BigDecimal.new(&quot;1.2&quot;) - BigDecimal(&quot;1.0&quot;)) == BigDecimal(&quot;0.2&quot;) -&gt; true&lt;/p&gt;&lt;p&gt;(1.2 - 1.0) == 0.2 -&gt; false&lt;/p&gt;&lt;h1&gt;Special features of accurate decimal arithmetic&lt;/h1&gt;&lt;p&gt;Because BigDecimal is more accurate than normal binary floating point arithmetic, it requires some special values.&lt;/p&gt;&lt;h2&gt;Infinity&lt;/h2&gt;&lt;p&gt;BigDecimal sometimes needs to return infinity, for example if you divide a value by zero.&lt;/p&gt;&lt;p&gt;BigDecimal.new(&quot;1.0&quot;) / BigDecimal.new(&quot;0.0&quot;) -&gt; infinity&lt;/p&gt;&lt;p&gt;BigDecimal.new(&quot;-1.0&quot;) / BigDecimal.new(&quot;0.0&quot;) -&gt; -infinity&lt;/p&gt;&lt;p&gt;You can represent infinite numbers to BigDecimal using the strings &apos;Infinity&apos;, &apos;+Infinity&apos; and &apos;-Infinity&apos; (case-sensitive)&lt;/p&gt;&lt;h2&gt;Not a Number&lt;/h2&gt;&lt;p&gt;When a computation results in an undefined value, the special value NaN (for &apos;not a number&apos;) is returned.&lt;/p&gt;&lt;p&gt;Example:&lt;/p&gt;&lt;p&gt;BigDecimal.new(&quot;0.0&quot;) / BigDecimal.new(&quot;0.0&quot;) -&gt; NaN&lt;/p&gt;&lt;p&gt;You can also create undefined values. NaN is never considered to be the same as any other value, even NaN itself:&lt;/p&gt;&lt;p&gt;n = BigDecimal.new(&apos;NaN&apos;)&lt;/p&gt;&lt;p&gt;n == 0.0 -&gt; nil&lt;/p&gt;&lt;p&gt;n == n -&gt; nil&lt;/p&gt;&lt;h2&gt;Positive and negative zero&lt;/h2&gt;&lt;p&gt;If a computation results in a value which is too small to be represented as a BigDecimal within the currently specified limits of precision, zero must be returned.&lt;/p&gt;&lt;p&gt;If the value which is too small to be represented is negative, a BigDecimal value of negative zero is returned. If the value is positive, a value of positive zero is returned.&lt;/p&gt;&lt;p&gt;BigDecimal.new(&quot;1.0&quot;) / BigDecimal.new(&quot;-Infinity&quot;) -&gt; -0.0&lt;/p&gt;&lt;p&gt;BigDecimal.new(&quot;1.0&quot;) / BigDecimal.new(&quot;Infinity&quot;) -&gt; 0.0&lt;/p&gt;&lt;p&gt;(See BigDecimal.mode for how to specify limits of precision.)&lt;/p&gt;&lt;p&gt;Note that -0.0 and 0.0 are considered to be the same for the purposes of comparison.&lt;/p&gt;&lt;p&gt;Note also that in mathematics, there is no particular concept of negative or positive zero; true mathematical zero has no sign.&lt;/p&gt;</comment>
  <methods>
    <method name='_load'>&lt;p&gt;Internal method used to provide marshalling support. See the Marshal module.&lt;/p&gt;</method>
    <method name='double_fig'>&lt;p&gt;The BigDecimal.double_fig class method returns the number of digits a Float number is allowed to have. The result depends upon the CPU and OS in use.&lt;/p&gt;</method>
    <method name='limit'>&lt;p&gt;Limit the number of significant digits in newly created BigDecimal numbers to the specified value. Rounding is performed as necessary, as specified by BigDecimal.mode.&lt;/p&gt;&lt;p&gt;A limit of 0, the default, means no upper limit.&lt;/p&gt;&lt;p&gt;The limit specified by this method takes priority over any limit specified to instance methods such as ceil, floor, truncate, or round.&lt;/p&gt;</method>
    <method name='mode'>&lt;p&gt;Controls handling of arithmetic exceptions and rounding. If no value is supplied, the current value is returned.&lt;/p&gt;&lt;p&gt;Six values of the mode parameter control the handling of arithmetic exceptions:&lt;/p&gt;&lt;p&gt;BigDecimal::EXCEPTION_NaN BigDecimal::EXCEPTION_INFINITY BigDecimal::EXCEPTION_UNDERFLOW BigDecimal::EXCEPTION_OVERFLOW BigDecimal::EXCEPTION_ZERODIVIDE BigDecimal::EXCEPTION_ALL&lt;/p&gt;&lt;p&gt;For each mode parameter above, if the value set is false, computation continues after an arithmetic exception of the appropriate type. When computation continues, results are as follows:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;NaN&lt;/li&gt;&lt;li&gt;+infinity or -infinity&lt;/li&gt;&lt;li&gt;0&lt;/li&gt;&lt;li&gt;+infinity or -infinity&lt;/li&gt;&lt;li&gt;+infinity or -infinity&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;One value of the mode parameter controls the rounding of numeric values: BigDecimal::ROUND_MODE. The values it can take are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;round away from zero&lt;/li&gt;&lt;li&gt;round towards zero (truncate)&lt;/li&gt;&lt;li&gt;round up if the appropriate digit &gt;= 5, otherwise truncate (default)&lt;/li&gt;&lt;li&gt;round up if the appropriate digit &gt;= 6, otherwise truncate&lt;/li&gt;&lt;li&gt;round towards the even neighbor (Banker&apos;s rounding)&lt;/li&gt;&lt;li&gt;round towards positive infinity (ceil)&lt;/li&gt;&lt;li&gt;round towards negative infinity (floor)&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='new'>&lt;p&gt;Create a new BigDecimal object.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The initial value, as a String. Spaces are ignored, unrecognized characters terminate the value.&lt;/li&gt;&lt;li&gt;The number of significant digits, as a Fixnum. If omitted or 0, the number of significant digits is determined from the initial value.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The actual number of significant digits used in computation is usually larger than the specified number.&lt;/p&gt;</method>
    <method name='ver'>&lt;p&gt;Returns the BigDecimal version number.&lt;/p&gt;&lt;p&gt;Ruby 1.8.0 returns 1.0.0. Ruby 1.8.1 thru 1.8.3 return 1.0.1.&lt;/p&gt;</method>
    <method name='!='>&lt;p&gt;Returns true if the values are not equal in value. Values may be coerced to perform the comparison:&lt;/p&gt;&lt;p&gt;BigDecimal.new(&apos;1.0&apos;) != 1.0 -&gt; false&lt;/p&gt;</method>
    <method name='%'>&lt;p&gt;Returns the modulus from dividing by b. See divmod.&lt;/p&gt;</method>
    <method name='*'>&lt;p&gt;Multiply by the specified value.&lt;/p&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;pre&gt;  c = a.mult(b,n)
  c = a * b
&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to BigDecimal.mode.&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='**'>&lt;p&gt;Returns the value raised to the power of n. Note that n must be an Integer.&lt;/p&gt;&lt;p&gt;Also available as the operator **&lt;/p&gt;</method>
    <method name='+'>&lt;p&gt;Add the specified value.&lt;/p&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;pre&gt;  c = a.add(b,n)
  c = a + b
&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to BigDecimal.mode.&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='-'>&lt;p&gt;Subtract the specified value.&lt;/p&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;pre&gt;  c = a.sub(b,n)
  c = a - b
&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to BigDecimal.mode.&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='/'>&lt;p&gt;Divide by the specified value.&lt;/p&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;pre&gt;  c = a.div(b,n)
&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to BigDecimal.mode.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;If digits is 0, the result is the same as the / operator. If not, the result is an integer BigDecimal, by analogy with Float#div.&lt;/p&gt;&lt;p&gt;The alias quo is provided since div(value, 0) is the same as computing the quotient; see divmod.&lt;/p&gt;</method>
    <method name='&lt;'>&lt;p&gt;Returns true if a is less than b. Values may be coerced to perform the comparison (see ==, coerce).&lt;/p&gt;</method>
    <method name='&lt;='>&lt;p&gt;Returns true if a is less than or equal to b. Values may be coerced to perform the comparison (see ==, coerce).&lt;/p&gt;</method>
    <method name='&lt;=&gt;'>&lt;p&gt;The comparison operator. a &lt;=&gt; b is 0 if a == b, 1 if a &gt; b, -1 if a &lt; b.&lt;/p&gt;</method>
    <method name='=='>&lt;p&gt;Tests for value equality; returns true if the values are equal.&lt;/p&gt;&lt;p&gt;The == and === operators and the eql? method have the same implementation for BigDecimal.&lt;/p&gt;&lt;p&gt;Values may be coerced to perform the comparison:&lt;/p&gt;&lt;p&gt;BigDecimal.new(&apos;1.0&apos;) == 1.0 -&gt; true&lt;/p&gt;</method>
    <method name='==='>&lt;p&gt;Tests for value equality; returns true if the values are equal.&lt;/p&gt;&lt;p&gt;The == and === operators and the eql? method have the same implementation for BigDecimal.&lt;/p&gt;&lt;p&gt;Values may be coerced to perform the comparison:&lt;/p&gt;&lt;p&gt;BigDecimal.new(&apos;1.0&apos;) == 1.0 -&gt; true&lt;/p&gt;</method>
    <method name='&gt;'>&lt;p&gt;Returns true if a is greater than b. Values may be coerced to perform the comparison (see ==, coerce).&lt;/p&gt;</method>
    <method name='&gt;='>&lt;p&gt;Returns true if a is greater than or equal to b. Values may be coerced to perform the comparison (see ==, coerce)&lt;/p&gt;</method>
    <method name='abs'>&lt;p&gt;Returns the absolute value.&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;5&apos;).abs -&gt; 5&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;-3&apos;).abs -&gt; 3&lt;/p&gt;</method>
    <method name='ceil'>&lt;p&gt;Return the smallest integer greater than or equal to the value, as a BigDecimal.&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;3.14159&apos;).ceil -&gt; 4&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;-9.1&apos;).ceil -&gt; -9&lt;/p&gt;&lt;p&gt;If n is specified and positive, the fractional part of the result has no more than that many digits.&lt;/p&gt;&lt;p&gt;If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result.&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;3.14159&apos;).ceil(3) -&gt; 3.142&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;13345.234&apos;).ceil(-2) -&gt; 13400.0&lt;/p&gt;</method>
    <method name='coerce'>&lt;p&gt;The coerce method provides support for Ruby type coercion. It is not enabled by default.&lt;/p&gt;&lt;p&gt;This means that binary operations like + * / or - can often be performed on a BigDecimal and an object of another type, if the other object can be coerced into a BigDecimal value.&lt;/p&gt;&lt;p&gt;e.g. a = BigDecimal.new(&quot;1.0&quot;) b = a / 2.0 -&gt; 0.5&lt;/p&gt;&lt;p&gt;Note that coercing a String to a BigDecimal is not supported by default; it requires a special compile-time option when building Ruby.&lt;/p&gt;</method>
    <method name='divmod'>&lt;p&gt;Divides by the specified value, and returns the quotient and modulus as BigDecimal numbers. The quotient is rounded towards negative infinity.&lt;/p&gt;&lt;p&gt;For example:&lt;/p&gt;&lt;p&gt;require &apos;bigdecimal&apos;&lt;/p&gt;&lt;p&gt;a = BigDecimal.new(&quot;42&quot;) b = BigDecimal.new(&quot;9&quot;)&lt;/p&gt;&lt;p&gt;q,m = a.divmod(b)&lt;/p&gt;&lt;p&gt;c = q * b + m&lt;/p&gt;&lt;p&gt;a == c -&gt; true&lt;/p&gt;&lt;p&gt;The quotient q is (a/b).floor, and the modulus is the amount that must be added to q * b to get a.&lt;/p&gt;</method>
    <method name='eql?'>&lt;p&gt;Tests for value equality; returns true if the values are equal.&lt;/p&gt;&lt;p&gt;The == and === operators and the eql? method have the same implementation for BigDecimal.&lt;/p&gt;&lt;p&gt;Values may be coerced to perform the comparison:&lt;/p&gt;&lt;p&gt;BigDecimal.new(&apos;1.0&apos;) == 1.0 -&gt; true&lt;/p&gt;</method>
    <method name='exponent'>&lt;p&gt;Returns the exponent of the BigDecimal number, as an Integer.&lt;/p&gt;&lt;p&gt;If the number can be represented as 0.xxxxxx*10**n where xxxxxx is a string of digits with no leading zeros, then n is the exponent.&lt;/p&gt;</method>
    <method name='finite?'>&lt;p&gt;Returns True if the value is finite (not NaN or infinite)&lt;/p&gt;</method>
    <method name='fix'>&lt;p&gt;Return the integer part of the number.&lt;/p&gt;</method>
    <method name='floor'>&lt;p&gt;Return the largest integer less than or equal to the value, as a BigDecimal.&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;3.14159&apos;).floor -&gt; 3&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;-9.1&apos;).floor -&gt; -10&lt;/p&gt;&lt;p&gt;If n is specified and positive, the fractional part of the result has no more than that many digits.&lt;/p&gt;&lt;p&gt;If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result.&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;3.14159&apos;).floor(3) -&gt; 3.141&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;13345.234&apos;).floor(-2) -&gt; 13300.0&lt;/p&gt;</method>
    <method name='frac'>&lt;p&gt;Return the fractional part of the number.&lt;/p&gt;</method>
    <method name='infinite?'>&lt;p&gt;Returns True if the value is infinite&lt;/p&gt;</method>
    <method name='inspect'>&lt;p&gt;Returns debugging information about the value as a string of comma-separated values in angle brackets with a leading #:&lt;/p&gt;&lt;p&gt;BigDecimal.new(&quot;1234.5678&quot;).inspect -&gt; &quot;#&lt;BigDecimal:b7ea1130,&apos;0.12345678E4&apos;,8(12)&gt;&quot;&lt;/p&gt;&lt;p&gt;The first part is the address, the second is the value as a string, and the final part ss(mm) is the current number of significant digits and the maximum number of significant digits, respectively.&lt;/p&gt;</method>
    <method name='modulo'>&lt;p&gt;Returns the modulus from dividing by b. See divmod.&lt;/p&gt;</method>
    <method name='nan?'>&lt;p&gt;Returns True if the value is Not a Number&lt;/p&gt;</method>
    <method name='nonzero?'>&lt;p&gt;Returns True if the value is non-zero.&lt;/p&gt;</method>
    <method name='power'>&lt;p&gt;Returns the value raised to the power of n. Note that n must be an Integer.&lt;/p&gt;&lt;p&gt;Also available as the operator **&lt;/p&gt;</method>
    <method name='precs'>&lt;p&gt;Returns an Array of two Integer values.&lt;/p&gt;&lt;p&gt;The first value is the current number of significant digits in the BigDecimal. The second value is the maximum number of significant digits for the BigDecimal.&lt;/p&gt;</method>
    <method name='quo'>&lt;p&gt;Divide by the specified value.&lt;/p&gt;&lt;p&gt;e.g.&lt;/p&gt;&lt;pre&gt;  c = a.div(b,n)
&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to BigDecimal.mode.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;If digits is 0, the result is the same as the / operator. If not, the result is an integer BigDecimal, by analogy with Float#div.&lt;/p&gt;&lt;p&gt;The alias quo is provided since div(value, 0) is the same as computing the quotient; see divmod.&lt;/p&gt;</method>
    <method name='remainder'>&lt;p&gt;Returns the remainder from dividing by the value.&lt;/p&gt;&lt;p&gt;If the values divided are of the same sign, the remainder is the same as the modulus (see divmod).&lt;/p&gt;&lt;p&gt;Otherwise, the remainder is the modulus minus the value divided by.&lt;/p&gt;</method>
    <method name='round'>&lt;p&gt;Round to the nearest 1 (by default), returning the result as a BigDecimal.&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;3.14159&apos;).round -&gt; 3&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;8.7&apos;).round -&gt; 9&lt;/p&gt;&lt;p&gt;If n is specified and positive, the fractional part of the result has no more than that many digits.&lt;/p&gt;&lt;p&gt;If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result.&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;3.14159&apos;).round(3) -&gt; 3.142&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;13345.234&apos;).round(-2) -&gt; 13300.0&lt;/p&gt;&lt;p&gt;The value of the optional mode argument can be used to determine how rounding is performed; see BigDecimal.mode.&lt;/p&gt;</method>
    <method name='sign'>&lt;p&gt;Returns the sign of the value.&lt;/p&gt;&lt;p&gt;Returns a positive value if &gt; 0, a negative value if &lt; 0, and a zero if == 0.&lt;/p&gt;&lt;p&gt;The specific value returned indicates the type and sign of the BigDecimal, as follows:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;value is Not a Number&lt;/li&gt;&lt;li&gt;value is +0&lt;/li&gt;&lt;li&gt;value is -0&lt;/li&gt;&lt;li&gt;value is +infinity&lt;/li&gt;&lt;li&gt;value is -infinity&lt;/li&gt;&lt;li&gt;value is positive&lt;/li&gt;&lt;li&gt;value is negative&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='split'>&lt;p&gt;Splits a BigDecimal number into four parts, returned as an array of values.&lt;/p&gt;&lt;p&gt;The first value represents the sign of the BigDecimal, and is -1 or 1, or 0 if the BigDecimal is Not a Number.&lt;/p&gt;&lt;p&gt;The second value is a string representing the significant digits of the BigDecimal, with no leading zeros.&lt;/p&gt;&lt;p&gt;The third value is the base used for arithmetic (currently always 10) as an Integer.&lt;/p&gt;&lt;p&gt;The fourth value is an Integer exponent.&lt;/p&gt;&lt;p&gt;If the BigDecimal can be represented as 0.xxxxxx*10**n, then xxxxxx is the string of significant digits with no leading zeros, and n is the exponent.&lt;/p&gt;&lt;p&gt;From these values, you can translate a BigDecimal to a float as follows:&lt;/p&gt;&lt;pre&gt;  sign, significant_digits, base, exponent = a.split
  f = sign * &quot;0.#{significant_digits}&quot;.to_f * (base ** exponent)
&lt;/pre&gt;&lt;p&gt;(Note that the to_f method is provided as a more convenient way to translate a BigDecimal to a Float.)&lt;/p&gt;</method>
    <method name='sqrt'>&lt;p&gt;Returns the square root of the value.&lt;/p&gt;&lt;p&gt;If n is specified, returns at least that many significant digits.&lt;/p&gt;</method>
    <method name='to_f'>&lt;p&gt;Returns a new Float object having approximately the same value as the BigDecimal number. Normal accuracy limits and built-in errors of binary Float arithmetic apply.&lt;/p&gt;</method>
    <method name='to_i'>&lt;p&gt;Returns the value as an integer (Fixnum or Bignum).&lt;/p&gt;&lt;p&gt;If the BigNumber is infinity or NaN, returns nil.&lt;/p&gt;</method>
    <method name='to_int'>&lt;p&gt;Returns the value as an integer (Fixnum or Bignum).&lt;/p&gt;&lt;p&gt;If the BigNumber is infinity or NaN, returns nil.&lt;/p&gt;</method>
    <method name='to_s'>&lt;p&gt;Converts the value to a string.&lt;/p&gt;&lt;p&gt;The default format looks like 0.xxxxEnn.&lt;/p&gt;&lt;p&gt;The optional parameter s consists of either an integer; or an optional &apos;+&apos; or &apos; &apos;, followed by an optional number, followed by an optional &apos;E&apos; or &apos;F&apos;.&lt;/p&gt;&lt;p&gt;If there is a &apos;+&apos; at the start of s, positive values are returned with a leading &apos;+&apos;.&lt;/p&gt;&lt;p&gt;A space at the start of s returns positive values with a leading space.&lt;/p&gt;&lt;p&gt;If s contains a number, a space is inserted after each group of that many fractional digits.&lt;/p&gt;&lt;p&gt;If s ends with an &apos;E&apos;, engineering notation (0.xxxxEnn) is used.&lt;/p&gt;&lt;p&gt;If s ends with an &apos;F&apos;, conventional floating point notation is used.&lt;/p&gt;&lt;p&gt;Examples:&lt;/p&gt;&lt;p&gt;BigDecimal.new(&apos;-123.45678901234567890&apos;).to_s(&apos;5F&apos;) -&gt; &apos;-123.45678 90123 45678 9&apos;&lt;/p&gt;&lt;p&gt;BigDecimal.new(&apos;123.45678901234567890&apos;).to_s(&apos;+8F&apos;) -&gt; &apos;+123.45678901 23456789&apos;&lt;/p&gt;&lt;p&gt;BigDecimal.new(&apos;123.45678901234567890&apos;).to_s(&apos; F&apos;) -&gt; &apos; 123.4567890123456789&apos;&lt;/p&gt;</method>
    <method name='truncate'>&lt;p&gt;Truncate to the nearest 1, returning the result as a BigDecimal.&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;3.14159&apos;).truncate -&gt; 3&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;8.7&apos;).truncate -&gt; 8&lt;/p&gt;&lt;p&gt;If n is specified and positive, the fractional part of the result has no more than that many digits.&lt;/p&gt;&lt;p&gt;If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result.&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;3.14159&apos;).truncate(3) -&gt; 3.141&lt;/p&gt;&lt;p&gt;BigDecimal(&apos;13345.234&apos;).truncate(-2) -&gt; 13300.0&lt;/p&gt;</method>
    <method name='zero?'>&lt;p&gt;Returns True if the value is zero.&lt;/p&gt;</method>
  </methods>
</help>