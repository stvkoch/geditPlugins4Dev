<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<help>
  <comment>&lt;p&gt;Net::IMAP implements Internet Message Access Protocol (IMAP) client functionality. The protocol is described in [IMAP].&lt;/p&gt;&lt;h2&gt;IMAP Overview&lt;/h2&gt;&lt;p&gt;An IMAP client connects to a server, and then authenticates itself using either #authenticate() or #login(). Having authenticated itself, there is a range of commands available to it. Most work with mailboxes, which may be arranged in an hierarchical namespace, and each of which contains zero or more messages. How this is implemented on the server is implementation-dependent; on a UNIX server, it will frequently be implemented as a files in mailbox format within a hierarchy of directories.&lt;/p&gt;&lt;p&gt;To work on the messages within a mailbox, the client must first select that mailbox, using either #select() or (for read-only access) #examine(). Once the client has successfully selected a mailbox, they enter &lt;em&gt;selected&lt;/em&gt; state, and that mailbox becomes the &lt;em&gt;current&lt;/em&gt; mailbox, on which mail-item related commands implicitly operate.&lt;/p&gt;&lt;p&gt;Messages have two sorts of identifiers: message sequence numbers, and UIDs.&lt;/p&gt;&lt;p&gt;Message sequence numbers number messages within a mail box from 1 up to the number of items in the mail box. If new message arrives during a session, it receives a sequence number equal to the new size of the mail box. If messages are expunged from the mailbox, remaining messages have their sequence numbers &quot;shuffled down&quot; to fill the gaps.&lt;/p&gt;&lt;p&gt;UIDs, on the other hand, are permanently guaranteed not to identify another message within the same mailbox, even if the existing message is deleted. UIDs are required to be assigned in ascending (but not necessarily sequential) order within a mailbox; this means that if a non-IMAP client rearranges the order of mailitems within a mailbox, the UIDs have to be reassigned. An IMAP client cannot thus rearrange message orders.&lt;/p&gt;&lt;h2&gt;Examples of Usage&lt;/h2&gt;&lt;h3&gt;List sender and subject of all recent messages in the default mailbox&lt;/h3&gt;&lt;pre&gt;  imap = Net::IMAP.new(&apos;mail.example.com&apos;)
  imap.authenticate(&apos;LOGIN&apos;, &apos;joe_user&apos;, &apos;joes_password&apos;)
  imap.examine(&apos;INBOX&apos;)
  imap.search([&quot;RECENT&quot;]).each do |message_id|
    envelope = imap.fetch(message_id, &quot;ENVELOPE&quot;)[0].attr[&quot;ENVELOPE&quot;]
    puts &quot;#{envelope.from[0].name}: \t#{envelope.subject}&quot;
  end
&lt;/pre&gt;&lt;h3&gt;Move all messages from April 2003 from &quot;Mail/sent-mail&quot; to &quot;Mail/sent-apr03&quot;&lt;/h3&gt;&lt;pre&gt;  imap = Net::IMAP.new(&apos;mail.example.com&apos;)
  imap.authenticate(&apos;LOGIN&apos;, &apos;joe_user&apos;, &apos;joes_password&apos;)
  imap.select(&apos;Mail/sent-mail&apos;)
  if not imap.list(&apos;Mail/&apos;, &apos;sent-apr03&apos;)
    imap.create(&apos;Mail/sent-apr03&apos;)
  end
  imap.search([&quot;BEFORE&quot;, &quot;30-Apr-2003&quot;, &quot;SINCE&quot;, &quot;1-Apr-2003&quot;]).each do |message_id|
    imap.copy(message_id, &quot;Mail/sent-apr03&quot;)
    imap.store(message_id, &quot;+FLAGS&quot;, [:Deleted])
  end
  imap.expunge
&lt;/pre&gt;&lt;h2&gt;Thread Safety&lt;/h2&gt;&lt;p&gt;Net::IMAP supports concurrent threads. For example,&lt;/p&gt;&lt;pre&gt;  imap = Net::IMAP.new(&quot;imap.foo.net&quot;, &quot;imap2&quot;)
  imap.authenticate(&quot;cram-md5&quot;, &quot;bar&quot;, &quot;password&quot;)
  imap.select(&quot;inbox&quot;)
  fetch_thread = Thread.start { imap.fetch(1..-1, &quot;UID&quot;) }
  search_result = imap.search([&quot;BODY&quot;, &quot;hello&quot;])
  fetch_result = fetch_thread.value
  imap.disconnect
&lt;/pre&gt;&lt;p&gt;This script invokes the FETCH command and the SEARCH command concurrently.&lt;/p&gt;&lt;h2&gt;Errors&lt;/h2&gt;&lt;p&gt;An IMAP server can send three different types of responses to indicate failure:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;the attempted command could not be successfully completed. For instance, the username/password used for logging in are incorrect; the selected mailbox does not exists; etc.&lt;/li&gt;&lt;li&gt;the request from the client does not follow the server&apos;s understanding of the IMAP protocol. This includes attempting commands from the wrong client state; for instance, attempting to perform a SEARCH command without having SELECTed a current mailbox. It can also signal an internal server failure (such as a disk crash) has occurred.&lt;/li&gt;&lt;li&gt;the server is saying goodbye. This can be part of a normal logout sequence, and can be used as part of a login sequence to indicate that the server is (for some reason) unwilling to accept our connection. As a response to any other command, it indicates either that the server is shutting down, or that the server is timing out the client connection due to inactivity.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;These three error response are represented by the errors Net::IMAP::NoResponseError, Net::IMAP::BadResponseError, and Net::IMAP::ByeResponseError, all of which are subclasses of Net::IMAP::ResponseError. Essentially, all methods that involve sending a request to the server can generate one of these errors. Only the most pertinent instances have been documented below.&lt;/p&gt;&lt;p&gt;Because the IMAP class uses Sockets for communication, its methods are also susceptible to the various errors that can occur when working with sockets. These are generally represented as Errno errors. For instance, any method that involves sending a request to the server and/or receiving a response from it could raise an Errno::EPIPE error if the network connection unexpectedly goes down. See the socket(7), ip(7), tcp(7), socket(2), connect(2), and associated man pages.&lt;/p&gt;&lt;p&gt;Finally, a Net::IMAP::DataFormatError is thrown if low-level data is found to be in an incorrect format (for instance, when converting between UTF-8 and UTF-16), and Net::IMAP::ResponseParseError is thrown if a server response is non-parseable.&lt;/p&gt;&lt;h2&gt;References&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;M. Crispin, &quot;INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1&quot;, RFC 2060, December 1996. (Note: since obsoleted by RFC 3501)&lt;/li&gt;&lt;li&gt;Alvestrand, H., &quot;Tags for the Identification of Languages&quot;, RFC 1766, March 1995.&lt;/li&gt;&lt;li&gt;Myers, J., and M. Rose, &quot;The Content-MD5 Header Field&quot;, RFC 1864, October 1995.&lt;/li&gt;&lt;li&gt;Freed, N., and N. Borenstein, &quot;MIME (Multipurpose Internet Mail Extensions) Part One: Format of Internet Message Bodies&quot;, RFC 2045, November 1996.&lt;/li&gt;&lt;li&gt;Crocker, D., &quot;Standard for the Format of ARPA Internet Text Messages&quot;, STD 11, RFC 822, University of Delaware, August 1982.&lt;/li&gt;&lt;li&gt;Myers, J., &quot;IMAP4 QUOTA extension&quot;, RFC 2087, January 1997.&lt;/li&gt;&lt;li&gt;Myers, J., &quot;IMAP4 ACL extension&quot;, RFC 2086, January 1997.&lt;/li&gt;&lt;li&gt;Klensin, J., Catoe, R., and Krumviede, P., &quot;IMAP/POP AUTHorize Extension for Simple Challenge/Response&quot;, RFC 2195, September 1997.&lt;/li&gt;&lt;li&gt;Crispin, M., &quot;INTERNET MESSAGE ACCESS PROTOCOL - SORT and THREAD Extensions&quot;, draft-ietf-imapext-sort, May 2003.&lt;/li&gt;&lt;li&gt;http://www.openssl.org&lt;/li&gt;&lt;li&gt;http://savannah.gnu.org/projects/rubypki&lt;/li&gt;&lt;li&gt;Goldsmith, D. and Davis, M., &quot;UTF-7: A Mail-Safe Transformation Format of Unicode&quot;, RFC 2152, May 1997.&lt;/li&gt;&lt;/ul&gt;</comment>
  <methods>
    <method name='add_authenticator'>&lt;p&gt;Adds an authenticator for Net::IMAP#authenticate. &lt;tt&gt;auth_type&lt;/tt&gt; is the type of authentication this authenticator supports (for instance, &quot;LOGIN&quot;). The &lt;tt&gt;authenticator&lt;/tt&gt; is an object which defines a process() method to handle authentication with the server. See Net::IMAP::LoginAuthenticator and Net::IMAP::CramMD5Authenticator for examples.&lt;/p&gt;&lt;p&gt;If &lt;tt&gt;auth_type&lt;/tt&gt; refers to an existing authenticator, it will be replaced by the new one.&lt;/p&gt;</method>
    <method name='debug'>&lt;p&gt;Returns the debug mode.&lt;/p&gt;</method>
    <method name='debug='>&lt;p&gt;Sets the debug mode.&lt;/p&gt;</method>
    <method name='decode_utf7'>&lt;p&gt;Decode a string from modified UTF-7 format to UTF-8.&lt;/p&gt;&lt;p&gt;UTF-7 is a 7-bit encoding of Unicode [UTF7]. IMAP uses a slightly modified version of this to encode mailbox names containing non-ASCII characters; see [IMAP] section 5.1.3.&lt;/p&gt;&lt;p&gt;Net::IMAP does &lt;em&gt;not&lt;/em&gt; automatically encode and decode mailbox names to and from utf7.&lt;/p&gt;</method>
    <method name='encode_utf7'>&lt;p&gt;Encode a string from UTF-8 format to modified UTF-7.&lt;/p&gt;</method>
    <method name='new'>&lt;p&gt;Creates a new Net::IMAP object and connects it to the specified &lt;tt&gt;port&lt;/tt&gt; (143 by default) on the named &lt;tt&gt;host&lt;/tt&gt;. If &lt;tt&gt;usessl&lt;/tt&gt; is true, then an attempt will be made to use SSL (now TLS) to connect to the server. For this to work OpenSSL [OSSL] and the Ruby OpenSSL [RSSL] extensions need to be installed. The &lt;tt&gt;certs&lt;/tt&gt; parameter indicates the path or file containing the CA cert of the server, and the &lt;tt&gt;verify&lt;/tt&gt; parameter is for the OpenSSL verification callback.&lt;/p&gt;&lt;p&gt;The most common errors are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;connection refused by &lt;tt&gt;host&lt;/tt&gt; or an intervening firewall.&lt;/li&gt;&lt;li&gt;connection timed out (possibly due to packets being dropped by an intervening firewall).&lt;/li&gt;&lt;li&gt;there is no route to that network.&lt;/li&gt;&lt;li&gt;hostname not known or other socket error.&lt;/li&gt;&lt;li&gt;we connected to the host, but they immediately said goodbye to us.&lt;/li&gt;&lt;/ul&gt;</method>
    <method name='add_response_handler'>&lt;p&gt;Adds a response handler. For example, to detect when the server sends us a new EXISTS response (which normally indicates new messages being added to the mail box), you could add the following handler after selecting the mailbox.&lt;/p&gt;&lt;pre&gt;  imap.add_response_handler { |resp|
    if resp.kind_of?(Net::IMAP::UntaggedResponse) and resp.name == &quot;EXISTS&quot;
      puts &quot;Mailbox now has #{resp.data} messages&quot;
    end
  }
&lt;/pre&gt;</method>
    <method name='append'>&lt;p&gt;Sends a APPEND command to append the &lt;tt&gt;message&lt;/tt&gt; to the end of the &lt;tt&gt;mailbox&lt;/tt&gt;. The optional &lt;tt&gt;flags&lt;/tt&gt; argument is an array of flags to initially passing to the new message. The optional &lt;tt&gt;date_time&lt;/tt&gt; argument specifies the creation time to assign to the new message; it defaults to the current time. For example:&lt;/p&gt;&lt;pre&gt;  imap.append(&quot;inbox&quot;, &lt;&lt;EOF.gsub(/\n/, &quot;\r\n&quot;), [:Seen], Time.now)
  Subject: hello
  From: shugo@ruby-lang.org
  To: shugo@ruby-lang.org

  hello world
  EOF
&lt;/pre&gt;&lt;p&gt;A Net::IMAP::NoResponseError is raised if the mailbox does not exist (it is not created automatically), or if the flags, date_time, or message arguments contain errors.&lt;/p&gt;</method>
    <method name='authenticate'>&lt;p&gt;Sends an AUTHENTICATE command to authenticate the client. The &lt;tt&gt;auth_type&lt;/tt&gt; parameter is a string that represents the authentication mechanism to be used. Currently Net::IMAP supports authentication mechanisms:&lt;/p&gt;&lt;pre&gt;  LOGIN:: login using cleartext user and password.
  CRAM-MD5:: login with cleartext user and encrypted password
             (see [RFC-2195] for a full description).  This
             mechanism requires that the server have the user&apos;s
             password stored in clear-text password.
&lt;/pre&gt;&lt;p&gt;For both these mechanisms, there should be two &lt;tt&gt;args&lt;/tt&gt;: username and (cleartext) password. A server may not support one or other of these mechanisms; check #capability() for a capability of the form &quot;AUTH=LOGIN&quot; or &quot;AUTH=CRAM-MD5&quot;.&lt;/p&gt;&lt;p&gt;Authentication is done using the appropriate authenticator object: see @@authenticators for more information on plugging in your own authenticator.&lt;/p&gt;&lt;p&gt;For example:&lt;/p&gt;&lt;pre&gt;   imap.authenticate(&apos;LOGIN&apos;, user, password)
&lt;/pre&gt;&lt;p&gt;A Net::IMAP::NoResponseError is raised if authentication fails.&lt;/p&gt;</method>
    <method name='capability'>&lt;p&gt;Sends a CAPABILITY command, and returns an array of capabilities that the server supports. Each capability is a string. See [IMAP] for a list of possible capabilities.&lt;/p&gt;&lt;p&gt;Note that the Net::IMAP class does not modify its behaviour according to the capabilities of the server; it is up to the user of the class to ensure that a certain capability is supported by a server before using it.&lt;/p&gt;</method>
    <method name='check'>&lt;p&gt;Sends a CHECK command to request a checkpoint of the currently selected mailbox. This performs implementation-specific housekeeping, for instance, reconciling the mailbox&apos;s in-memory and on-disk state.&lt;/p&gt;</method>
    <method name='close'>&lt;p&gt;Sends a CLOSE command to close the currently selected mailbox. The CLOSE command permanently removes from the mailbox all messages that have the \Deleted flag set.&lt;/p&gt;</method>
    <method name='copy'>&lt;p&gt;Sends a COPY command to copy the specified message(s) to the end of the specified destination &lt;tt&gt;mailbox&lt;/tt&gt;. The &lt;tt&gt;set&lt;/tt&gt; parameter is a number or an array of numbers or a Range object. The number is a message sequence number.&lt;/p&gt;</method>
    <method name='create'>&lt;p&gt;Sends a CREATE command to create a new &lt;tt&gt;mailbox&lt;/tt&gt;.&lt;/p&gt;&lt;p&gt;A Net::IMAP::NoResponseError is raised if a mailbox with that name cannot be created.&lt;/p&gt;</method>
    <method name='delete'>&lt;p&gt;Sends a DELETE command to remove the &lt;tt&gt;mailbox&lt;/tt&gt;.&lt;/p&gt;&lt;p&gt;A Net::IMAP::NoResponseError is raised if a mailbox with that name cannot be deleted, either because it does not exist or because the client does not have permission to delete it.&lt;/p&gt;</method>
    <method name='disconnect'>&lt;p&gt;Disconnects from the server.&lt;/p&gt;</method>
    <method name='disconnected?'>&lt;p&gt;Returns true if disconnected from the server.&lt;/p&gt;</method>
    <method name='examine'>&lt;p&gt;Sends a EXAMINE command to select a &lt;tt&gt;mailbox&lt;/tt&gt; so that messages in the &lt;tt&gt;mailbox&lt;/tt&gt; can be accessed. Behaves the same as #select(), except that the selected &lt;tt&gt;mailbox&lt;/tt&gt; is identified as read-only.&lt;/p&gt;&lt;p&gt;A Net::IMAP::NoResponseError is raised if the mailbox does not exist or is for some reason non-examinable.&lt;/p&gt;</method>
    <method name='expunge'>&lt;p&gt;Sends a EXPUNGE command to permanently remove from the currently selected mailbox all messages that have the \Deleted flag set.&lt;/p&gt;</method>
    <method name='fetch'>&lt;p&gt;Sends a FETCH command to retrieve data associated with a message in the mailbox. The &lt;tt&gt;set&lt;/tt&gt; parameter is a number or an array of numbers or a Range object. The number is a message sequence number. &lt;tt&gt;attr&lt;/tt&gt; is a list of attributes to fetch; see the documentation for Net::IMAP::FetchData for a list of valid attributes. The return value is an array of Net::IMAP::FetchData. For example:&lt;/p&gt;&lt;pre&gt;  p imap.fetch(6..8, &quot;UID&quot;)
  #=&gt; [#&lt;Net::IMAP::FetchData seqno=6, attr={&quot;UID&quot;=&gt;98}&gt;, \
       #&lt;Net::IMAP::FetchData seqno=7, attr={&quot;UID&quot;=&gt;99}&gt;, \
       #&lt;Net::IMAP::FetchData seqno=8, attr={&quot;UID&quot;=&gt;100}&gt;]
  p imap.fetch(6, &quot;BODY[HEADER.FIELDS (SUBJECT)]&quot;)
  #=&gt; [#&lt;Net::IMAP::FetchData seqno=6, attr={&quot;BODY[HEADER.FIELDS (SUBJECT)]&quot;=&gt;&quot;Subject: test\r\n\r\n&quot;}&gt;]
  data = imap.uid_fetch(98, [&quot;RFC822.SIZE&quot;, &quot;INTERNALDATE&quot;])[0]
  p data.seqno
  #=&gt; 6
  p data.attr[&quot;RFC822.SIZE&quot;]
  #=&gt; 611
  p data.attr[&quot;INTERNALDATE&quot;]
  #=&gt; &quot;12-Oct-2000 22:40:59 +0900&quot;
  p data.attr[&quot;UID&quot;]
  #=&gt; 98
&lt;/pre&gt;</method>
    <method name='getacl'>&lt;p&gt;Send the GETACL command along with specified &lt;tt&gt;mailbox&lt;/tt&gt;. If this mailbox exists, an array containing objects of Net::IMAP::MailboxACLItem will be returned.&lt;/p&gt;</method>
    <method name='getquota'>&lt;p&gt;Sends the GETQUOTA command along with specified &lt;tt&gt;mailbox&lt;/tt&gt;. If this mailbox exists, then an array containing a Net::IMAP::MailboxQuota object is returned. This command generally is only available to server admin.&lt;/p&gt;</method>
    <method name='getquotaroot'>&lt;p&gt;Sends the GETQUOTAROOT command along with specified &lt;tt&gt;mailbox&lt;/tt&gt;. This command is generally available to both admin and user. If mailbox exists, returns an array containing objects of Net::IMAP::MailboxQuotaRoot and Net::IMAP::MailboxQuota.&lt;/p&gt;</method>
    <method name='list'>&lt;p&gt;Sends a LIST command, and returns a subset of names from the complete set of all names available to the client. &lt;tt&gt;refname&lt;/tt&gt; provides a context (for instance, a base directory in a directory-based mailbox hierarchy). &lt;tt&gt;mailbox&lt;/tt&gt; specifies a mailbox or (via wildcards) mailboxes under that context. Two wildcards may be used in &lt;tt&gt;mailbox&lt;/tt&gt;: &apos;*&apos;, which matches all characters &lt;b&gt;including&lt;/b&gt; the hierarchy delimiter (for instance, &apos;/&apos; on a UNIX-hosted directory-based mailbox hierarchy); and &apos;%&apos;, which matches all characters &lt;b&gt;except&lt;/b&gt; the hierarchy delimiter.&lt;/p&gt;&lt;p&gt;If &lt;tt&gt;refname&lt;/tt&gt; is empty, &lt;tt&gt;mailbox&lt;/tt&gt; is used directly to determine which mailboxes to match. If &lt;tt&gt;mailbox&lt;/tt&gt; is empty, the root name of &lt;tt&gt;refname&lt;/tt&gt; and the hierarchy delimiter are returned.&lt;/p&gt;&lt;p&gt;The return value is an array of +Net::IMAP::MailboxList+. For example:&lt;/p&gt;&lt;pre&gt;  imap.create(&quot;foo/bar&quot;)
  imap.create(&quot;foo/baz&quot;)
  p imap.list(&quot;&quot;, &quot;foo/%&quot;)
  #=&gt; [#&lt;Net::IMAP::MailboxList attr=[:Noselect], delim=&quot;/&quot;, name=&quot;foo/&quot;&gt;, \
       #&lt;Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim=&quot;/&quot;, name=&quot;foo/bar&quot;&gt;, \
       #&lt;Net::IMAP::MailboxList attr=[:Noinferiors], delim=&quot;/&quot;, name=&quot;foo/baz&quot;&gt;]
&lt;/pre&gt;</method>
    <method name='login'>&lt;p&gt;Sends a LOGIN command to identify the client and carries the plaintext &lt;tt&gt;password&lt;/tt&gt; authenticating this &lt;tt&gt;user&lt;/tt&gt;. Note that, unlike calling #authenticate() with an &lt;tt&gt;auth_type&lt;/tt&gt; of &quot;LOGIN&quot;, #login() does &lt;b&gt;not&lt;/b&gt; use the login authenticator.&lt;/p&gt;&lt;p&gt;A Net::IMAP::NoResponseError is raised if authentication fails.&lt;/p&gt;</method>
    <method name='logout'>&lt;p&gt;Sends a LOGOUT command to inform the server that the client is done with the connection.&lt;/p&gt;</method>
    <method name='lsub'>&lt;p&gt;Sends a LSUB command, and returns a subset of names from the set of names that the user has declared as being &quot;active&quot; or &quot;subscribed&quot;. &lt;tt&gt;refname&lt;/tt&gt; and &lt;tt&gt;mailbox&lt;/tt&gt; are interpreted as for #list(). The return value is an array of +Net::IMAP::MailboxList+.&lt;/p&gt;</method>
    <method name='noop'>&lt;p&gt;Sends a NOOP command to the server. It does nothing.&lt;/p&gt;</method>
    <method name='remove_response_handler'>&lt;p&gt;Removes the response handler.&lt;/p&gt;</method>
    <method name='rename'>&lt;p&gt;Sends a RENAME command to change the name of the &lt;tt&gt;mailbox&lt;/tt&gt; to &lt;tt&gt;newname&lt;/tt&gt;.&lt;/p&gt;&lt;p&gt;A Net::IMAP::NoResponseError is raised if a mailbox with the name &lt;tt&gt;mailbox&lt;/tt&gt; cannot be renamed to &lt;tt&gt;newname&lt;/tt&gt; for whatever reason; for instance, because &lt;tt&gt;mailbox&lt;/tt&gt; does not exist, or because there is already a mailbox with the name &lt;tt&gt;newname&lt;/tt&gt;.&lt;/p&gt;</method>
    <method name='search'>&lt;p&gt;Sends a SEARCH command to search the mailbox for messages that match the given searching criteria, and returns message sequence numbers. &lt;tt&gt;keys&lt;/tt&gt; can either be a string holding the entire search string, or a single-dimension array of search keywords and arguments. The following are some common search criteria; see [IMAP] section 6.4.4 for a full list.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;a set of message sequence numbers. &apos;,&apos; indicates an interval, &apos;:&apos; indicates a range. For instance, &apos;2,10:12,15&apos; means &quot;2,10,11,12,15&quot;.&lt;/li&gt;&lt;li&gt;messages with an internal date strictly before &lt;date&gt;. The date argument has a format similar to 8-Aug-2002.&lt;/li&gt;&lt;li&gt;messages that contain &lt;string&gt; within their body.&lt;/li&gt;&lt;li&gt;messages containing &lt;string&gt; in their CC field.&lt;/li&gt;&lt;li&gt;messages that contain &lt;string&gt; in their FROM field.&lt;/li&gt;&lt;li&gt;messages with the \Recent, but not the \Seen, flag set.&lt;/li&gt;&lt;li&gt;negate the following search key.&lt;/li&gt;&lt;li&gt;&quot;or&quot; two search keys together.&lt;/li&gt;&lt;li&gt;messages with an internal date exactly equal to &lt;date&gt;, which has a format similar to 8-Aug-2002.&lt;/li&gt;&lt;li&gt;messages with an internal date on or after &lt;date&gt;.&lt;/li&gt;&lt;li&gt;messages with &lt;string&gt; in their subject.&lt;/li&gt;&lt;li&gt;messages with &lt;string&gt; in their TO field.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;For example:&lt;/p&gt;&lt;pre&gt;  p imap.search([&quot;SUBJECT&quot;, &quot;hello&quot;, &quot;NOT&quot;, &quot;NEW&quot;])
  #=&gt; [1, 6, 7, 8]
&lt;/pre&gt;</method>
    <method name='select'>&lt;p&gt;Sends a SELECT command to select a &lt;tt&gt;mailbox&lt;/tt&gt; so that messages in the &lt;tt&gt;mailbox&lt;/tt&gt; can be accessed.&lt;/p&gt;&lt;p&gt;After you have selected a mailbox, you may retrieve the number of items in that mailbox from @responses[&quot;EXISTS&quot;][-1], and the number of recent messages from @responses[&quot;RECENT&quot;][-1]. Note that these values can change if new messages arrive during a session; see #add_response_handler() for a way of detecting this event.&lt;/p&gt;&lt;p&gt;A Net::IMAP::NoResponseError is raised if the mailbox does not exist or is for some reason non-selectable.&lt;/p&gt;</method>
    <method name='setacl'>&lt;p&gt;Sends the SETACL command along with &lt;tt&gt;mailbox&lt;/tt&gt;, &lt;tt&gt;user&lt;/tt&gt; and the &lt;tt&gt;rights&lt;/tt&gt; that user is to have on that mailbox. If &lt;tt&gt;rights&lt;/tt&gt; is nil, then that user will be stripped of any rights to that mailbox. The IMAP ACL commands are described in [RFC-2086].&lt;/p&gt;</method>
    <method name='setquota'>&lt;p&gt;Sends a SETQUOTA command along with the specified &lt;tt&gt;mailbox&lt;/tt&gt; and &lt;tt&gt;quota&lt;/tt&gt;. If &lt;tt&gt;quota&lt;/tt&gt; is nil, then quota will be unset for that mailbox. Typically one needs to be logged in as server admin for this to work. The IMAP quota commands are described in [RFC-2087].&lt;/p&gt;</method>
    <method name='sort'>&lt;p&gt;Sends a SORT command to sort messages in the mailbox. Returns an array of message sequence numbers. For example:&lt;/p&gt;&lt;pre&gt;  p imap.sort([&quot;FROM&quot;], [&quot;ALL&quot;], &quot;US-ASCII&quot;)
  #=&gt; [1, 2, 3, 5, 6, 7, 8, 4, 9]
  p imap.sort([&quot;DATE&quot;], [&quot;SUBJECT&quot;, &quot;hello&quot;], &quot;US-ASCII&quot;)
  #=&gt; [6, 7, 8, 1]
&lt;/pre&gt;&lt;p&gt;See [SORT-THREAD-EXT] for more details.&lt;/p&gt;</method>
    <method name='status'>&lt;p&gt;Sends a STATUS command, and returns the status of the indicated &lt;tt&gt;mailbox&lt;/tt&gt;. &lt;tt&gt;attr&lt;/tt&gt; is a list of one or more attributes that we are request the status of. Supported attributes include:&lt;/p&gt;&lt;pre&gt;  MESSAGES:: the number of messages in the mailbox.
  RECENT:: the number of recent messages in the mailbox.
  UNSEEN:: the number of unseen messages in the mailbox.
&lt;/pre&gt;&lt;p&gt;The return value is a hash of attributes. For example:&lt;/p&gt;&lt;pre&gt;  p imap.status(&quot;inbox&quot;, [&quot;MESSAGES&quot;, &quot;RECENT&quot;])
  #=&gt; {&quot;RECENT&quot;=&gt;0, &quot;MESSAGES&quot;=&gt;44}
&lt;/pre&gt;&lt;p&gt;A Net::IMAP::NoResponseError is raised if status values for &lt;tt&gt;mailbox&lt;/tt&gt; cannot be returned, for instance because it does not exist.&lt;/p&gt;</method>
    <method name='store'>&lt;p&gt;Sends a STORE command to alter data associated with messages in the mailbox, in particular their flags. The &lt;tt&gt;set&lt;/tt&gt; parameter is a number or an array of numbers or a Range object. Each number is a message sequence number. &lt;tt&gt;attr&lt;/tt&gt; is the name of a data item to store: &apos;FLAGS&apos; means to replace the message&apos;s flag list with the provided one; &apos;+FLAGS&apos; means to add the provided flags; and &apos;-FLAGS&apos; means to remove them. &lt;tt&gt;flags&lt;/tt&gt; is a list of flags.&lt;/p&gt;&lt;p&gt;The return value is an array of Net::IMAP::FetchData. For example:&lt;/p&gt;&lt;pre&gt;  p imap.store(6..8, &quot;+FLAGS&quot;, [:Deleted])
  #=&gt; [#&lt;Net::IMAP::FetchData seqno=6, attr={&quot;FLAGS&quot;=&gt;[:Seen, :Deleted]}&gt;, \
       #&lt;Net::IMAP::FetchData seqno=7, attr={&quot;FLAGS&quot;=&gt;[:Seen, :Deleted]}&gt;, \
       #&lt;Net::IMAP::FetchData seqno=8, attr={&quot;FLAGS&quot;=&gt;[:Seen, :Deleted]}&gt;]
&lt;/pre&gt;</method>
    <method name='subscribe'>&lt;p&gt;Sends a SUBSCRIBE command to add the specified &lt;tt&gt;mailbox&lt;/tt&gt; name to the server&apos;s set of &quot;active&quot; or &quot;subscribed&quot; mailboxes as returned by #lsub().&lt;/p&gt;&lt;p&gt;A Net::IMAP::NoResponseError is raised if &lt;tt&gt;mailbox&lt;/tt&gt; cannot be subscribed to, for instance because it does not exist.&lt;/p&gt;</method>
    <method name='thread'>&lt;p&gt;As for #search(), but returns message sequence numbers in threaded format, as a Net::IMAP::ThreadMember tree. The supported algorithms are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;split into single-level threads according to subject, ordered by date.&lt;/li&gt;&lt;li&gt;split into threads by parent/child relationships determined by which message is a reply to which.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Unlike #search(), &lt;tt&gt;charset&lt;/tt&gt; is a required argument. US-ASCII and UTF-8 are sample values.&lt;/p&gt;&lt;p&gt;See [SORT-THREAD-EXT] for more details.&lt;/p&gt;</method>
    <method name='uid_copy'>&lt;p&gt;As for #copy(), but &lt;tt&gt;set&lt;/tt&gt; contains unique identifiers.&lt;/p&gt;</method>
    <method name='uid_fetch'>&lt;p&gt;As for #fetch(), but &lt;tt&gt;set&lt;/tt&gt; contains unique identifiers.&lt;/p&gt;</method>
    <method name='uid_search'>&lt;p&gt;As for #search(), but returns unique identifiers.&lt;/p&gt;</method>
    <method name='uid_sort'>&lt;p&gt;As for #sort(), but returns an array of unique identifiers.&lt;/p&gt;</method>
    <method name='uid_store'>&lt;p&gt;As for #store(), but &lt;tt&gt;set&lt;/tt&gt; contains unique identifiers.&lt;/p&gt;</method>
    <method name='uid_thread'>&lt;p&gt;As for #thread(), but returns unique identifiers instead of message sequence numbers.&lt;/p&gt;</method>
    <method name='unsubscribe'>&lt;p&gt;Sends a UNSUBSCRIBE command to remove the specified &lt;tt&gt;mailbox&lt;/tt&gt; name from the server&apos;s set of &quot;active&quot; or &quot;subscribed&quot; mailboxes.&lt;/p&gt;&lt;p&gt;A Net::IMAP::NoResponseError is raised if &lt;tt&gt;mailbox&lt;/tt&gt; cannot be unsubscribed from, for instance because the client is not currently subscribed to it.&lt;/p&gt;</method>
  </methods>
</help>